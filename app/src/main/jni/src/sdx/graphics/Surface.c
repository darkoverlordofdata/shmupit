/** updated by adriac */
/* Surface.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Surface.vala, do not modify */

/*[Adriac:Sdx.Graphics::Surface:SdxGraphicsSurface:sdx_graphics_surface]*/
/*[Adriac:Sdx.Graphics:Surface:CachedSurface:SdxGraphicsSurfaceCachedSurface:sdx_graphics_surface_cachedsurface]*/
/*[Adriac:Sdx.Graphics:Surface:TextureSurface:SdxGraphicsSurfaceTextureSurface:sdx_graphics_surface_texturesurface]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <SDL_surface.h>
#include <stdlib.h>
#include <string.h>
#include <SDL_rwops.h>
#include <SDL_image.h>

typedef struct _SdxGraphicsSurface SdxGraphicsSurface;
#define _SDL_FreeSurface0(var) ((var == NULL) ? NULL : (var = (SDL_FreeSurface (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
typedef SdxGraphicsSurface SdxGraphicsSurfaceCachedSurface;
typedef struct _SdxFilesFileHandle SdxFilesFileHandle;
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))
// symtbl.1 sdx_graphics_surface
void sdx_graphics_surface_release (SdxGraphicsSurface* self);
void sdx_graphics_surface_free (SdxGraphicsSurface* self);
SdxGraphicsSurface* sdx_graphics_surface_retain (SdxGraphicsSurface* self);
#define _sdx_graphics_surface_release0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_surface_release (var), NULL)))
// symtbl.1 sdx_files_file_handle
void sdx_files_file_handle_release (SdxFilesFileHandle* self);
void sdx_files_file_handle_free (SdxFilesFileHandle* self);
SdxFilesFileHandle* sdx_files_file_handle_retain (SdxFilesFileHandle* self);
#define _sdx_files_file_handle_release0(var) ((var == NULL) ? NULL : (var = (sdx_files_file_handle_release (var), NULL)))
typedef SdxGraphicsSurface SdxGraphicsSurfaceTextureSurface;

struct _SdxGraphicsSurface {
	gint ref_count;
	SDL_Surface* surface;
	gint id;
	gchar* path;
};

typedef enum  {
	SDX_SDL_EXCEPTION_Initialization,
	SDX_SDL_EXCEPTION_ImageInitialization,
	SDX_SDL_EXCEPTION_TtfInitialization,
	SDX_SDL_EXCEPTION_TextureFilteringNotEnabled,
	SDX_SDL_EXCEPTION_OpenWindow,
	SDX_SDL_EXCEPTION_CreateRenderer,
	SDX_SDL_EXCEPTION_InvalidForPlatform,
	SDX_SDL_EXCEPTION_UnableToLoadResource,
	SDX_SDL_EXCEPTION_UnableToLoadSurface,
	SDX_SDL_EXCEPTION_UnableToLoadTexture,
	SDX_SDL_EXCEPTION_NullPointer,
	SDX_SDL_EXCEPTION_NoSuchElement,
	SDX_SDL_EXCEPTION_IllegalStateException,
	SDX_SDL_EXCEPTION_IllegalArgumentException,
	SDX_SDL_EXCEPTION_RuntimeException,
	SDX_SDL_EXCEPTION_NotReached
} SdxSdlException;
#define SDX_SDL_EXCEPTION sdx_sdl_exception_quark ()

extern gint sdx_graphics_surface_uniqueId;
gint sdx_graphics_surface_uniqueId = 0;
extern SdxGraphicsSurface** sdx_graphics_surface_cached_surface_cache;
extern gint sdx_graphics_surface_cached_surface_cache_length1;
SdxGraphicsSurface** sdx_graphics_surface_cached_surface_cache = NULL;
gint sdx_graphics_surface_cached_surface_cache_length1 = 0;

void sdx_graphics_surface_free (SdxGraphicsSurface * self);
static void sdx_graphics_surface_instance_init (SdxGraphicsSurface * self);
SdxGraphicsSurface* sdx_graphics_surface_retain (SdxGraphicsSurface* self);
void sdx_graphics_surface_release (SdxGraphicsSurface* self);
void sdx_graphics_surface_free (SdxGraphicsSurface* self);
SDL_Surface* sdx_graphics_surface_GetSurface (SdxGraphicsSurface* self, const gchar* ext, SDL_RWops* raw);
GQuark sdx_sdl_exception_quark (void);
SdxGraphicsSurface* sdx_graphics_surface_new (void);
gint sdx_graphics_surface_get_width (SdxGraphicsSurface* self);
gint sdx_graphics_surface_get_height (SdxGraphicsSurface* self);
void sdx_graphics_surface_cached_surface_Initialize (gint size);
void sdx_files_file_handle_free (SdxFilesFileHandle * self);
SdxGraphicsSurfaceCachedSurface* sdx_graphics_surface_cached_surface_new (SdxFilesFileHandle* file);
gchar* sdx_files_file_handle_GetExt (SdxFilesFileHandle* self);
SDL_RWops* sdx_files_file_handle_GetRWops (SdxFilesFileHandle* self);
gchar* sdx_files_file_handle_GetPath (SdxFilesFileHandle* self);
gint sdx_graphics_surface_cached_surface_IndexOfPath (const gchar* path);
SdxFilesFileHandle* sdx_files_Default (const gchar* path);
SdxGraphicsSurfaceTextureSurface* sdx_graphics_surface_texture_surface_new (SdxFilesFileHandle* file);
void sdx_graphics_surface_texture_surface_SetFilter (SdxGraphicsSurfaceTextureSurface* self, gint minFilter, gint magFilter);
void sdx_graphics_surface_texture_surface_SetWrap (SdxGraphicsSurfaceTextureSurface* self, gint u, gint v);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);


SdxGraphicsSurface* sdx_graphics_surface_retain (SdxGraphicsSurface* self) {
	SdxGraphicsSurface* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_graphics_surface_release (SdxGraphicsSurface* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_graphics_surface_free (self);
	}
}


SDL_Surface* sdx_graphics_surface_GetSurface (SdxGraphicsSurface* self, const gchar* ext, SDL_RWops* raw) {
	SDL_Surface* result = NULL;
	const gchar* _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (ext != NULL, NULL);
	g_return_val_if_fail (raw != NULL, NULL);
	_tmp0_ = ext;
	if (g_strcmp0 (_tmp0_, ".png") == 0) {
		SDL_RWops* _tmp1_;
		SDL_Surface* _tmp2_;
		_tmp1_ = raw;
		_tmp2_ = IMG_LoadPNG_RW (_tmp1_);
		result = _tmp2_;
		return result;
	} else {
		const gchar* _tmp3_;
		_tmp3_ = ext;
		if (g_strcmp0 (_tmp3_, ".cur") == 0) {
			SDL_RWops* _tmp4_;
			SDL_Surface* _tmp5_;
			_tmp4_ = raw;
			_tmp5_ = IMG_LoadCUR_RW (_tmp4_);
			result = _tmp5_;
			return result;
		} else {
			const gchar* _tmp6_;
			_tmp6_ = ext;
			if (g_strcmp0 (_tmp6_, ".ico") == 0) {
				SDL_RWops* _tmp7_;
				SDL_Surface* _tmp8_;
				_tmp7_ = raw;
				_tmp8_ = IMG_LoadICO_RW (_tmp7_);
				result = _tmp8_;
				return result;
			} else {
				const gchar* _tmp9_;
				_tmp9_ = ext;
				if (g_strcmp0 (_tmp9_, ".bmp") == 0) {
					SDL_RWops* _tmp10_;
					SDL_Surface* _tmp11_;
					_tmp10_ = raw;
					_tmp11_ = IMG_LoadBMP_RW (_tmp10_);
					result = _tmp11_;
					return result;
				} else {
					const gchar* _tmp12_;
					_tmp12_ = ext;
					if (g_strcmp0 (_tmp12_, ".pnm") == 0) {
						SDL_RWops* _tmp13_;
						SDL_Surface* _tmp14_;
						_tmp13_ = raw;
						_tmp14_ = IMG_LoadPNM_RW (_tmp13_);
						result = _tmp14_;
						return result;
					} else {
						const gchar* _tmp15_;
						_tmp15_ = ext;
						if (g_strcmp0 (_tmp15_, ".xpm") == 0) {
							SDL_RWops* _tmp16_;
							SDL_Surface* _tmp17_;
							_tmp16_ = raw;
							_tmp17_ = IMG_LoadXPM_RW (_tmp16_);
							result = _tmp17_;
							return result;
						} else {
							const gchar* _tmp18_;
							_tmp18_ = ext;
							if (g_strcmp0 (_tmp18_, ".xcf") == 0) {
								SDL_RWops* _tmp19_;
								SDL_Surface* _tmp20_;
								_tmp19_ = raw;
								_tmp20_ = IMG_LoadXCF_RW (_tmp19_);
								result = _tmp20_;
								return result;
							} else {
								const gchar* _tmp21_;
								_tmp21_ = ext;
								if (g_strcmp0 (_tmp21_, ".pvx") == 0) {
									SDL_RWops* _tmp22_;
									SDL_Surface* _tmp23_;
									_tmp22_ = raw;
									_tmp23_ = IMG_LoadPCX_RW (_tmp22_);
									result = _tmp23_;
									return result;
								} else {
									const gchar* _tmp24_;
									_tmp24_ = ext;
									if (g_strcmp0 (_tmp24_, ".gif") == 0) {
										SDL_RWops* _tmp25_;
										SDL_Surface* _tmp26_;
										_tmp25_ = raw;
										_tmp26_ = IMG_LoadGIF_RW (_tmp25_);
										result = _tmp26_;
										return result;
									} else {
										const gchar* _tmp27_;
										_tmp27_ = ext;
										if (g_strcmp0 (_tmp27_, ".jpg") == 0) {
											SDL_RWops* _tmp28_;
											SDL_Surface* _tmp29_;
											_tmp28_ = raw;
											_tmp29_ = IMG_LoadJPG_RW (_tmp28_);
											result = _tmp29_;
											return result;
										} else {
											const gchar* _tmp30_;
											_tmp30_ = ext;
											if (g_strcmp0 (_tmp30_, ".tif") == 0) {
												SDL_RWops* _tmp31_;
												SDL_Surface* _tmp32_;
												_tmp31_ = raw;
												_tmp32_ = IMG_LoadTIF_RW (_tmp31_);
												result = _tmp32_;
												return result;
											} else {
												const gchar* _tmp33_;
												_tmp33_ = ext;
												if (g_strcmp0 (_tmp33_, ".tga") == 0) {
													SDL_RWops* _tmp34_;
													SDL_Surface* _tmp35_;
													_tmp34_ = raw;
													_tmp35_ = IMG_LoadTGA_RW (_tmp34_);
													result = _tmp35_;
													return result;
												} else {
													const gchar* _tmp36_;
													_tmp36_ = ext;
													if (g_strcmp0 (_tmp36_, ".lbm") == 0) {
														SDL_RWops* _tmp37_;
														SDL_Surface* _tmp38_;
														_tmp37_ = raw;
														_tmp38_ = IMG_LoadLBM_RW (_tmp37_);
														result = _tmp38_;
														return result;
													} else {
														const gchar* _tmp39_;
														_tmp39_ = ext;
														if (g_strcmp0 (_tmp39_, ".xv") == 0) {
															SDL_RWops* _tmp40_;
															SDL_Surface* _tmp41_;
															_tmp40_ = raw;
															_tmp41_ = IMG_LoadXV_RW (_tmp40_);
															result = _tmp41_;
															return result;
														} else {
															const gchar* _tmp42_;
															_tmp42_ = ext;
															if (g_strcmp0 (_tmp42_, ".webp") == 0) {
																SDL_RWops* _tmp43_;
																SDL_Surface* _tmp44_;
																_tmp43_ = raw;
																_tmp44_ = IMG_LoadWEBP_RW (_tmp43_);
																result = _tmp44_;
																return result;
															} else {
																const gchar* _tmp45_;
																GError* _tmp46_;
																_tmp45_ = ext;
																_tmp46_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_UnableToLoadSurface, _tmp45_);
																_inner_error_ = _tmp46_;
																g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
																g_clear_error (&_inner_error_);
																return NULL;
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


SdxGraphicsSurface* sdx_graphics_surface_new (void) {
	SdxGraphicsSurface* self;
	self = g_slice_new0 (SdxGraphicsSurface);
	sdx_graphics_surface_instance_init (self);
	return self;
}


gint sdx_graphics_surface_get_width (SdxGraphicsSurface* self) {
	gint result;
	SDL_Surface* _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->surface;
	_tmp1_ = _tmp0_->w;
	result = _tmp1_;
	return result;
}


gint sdx_graphics_surface_get_height (SdxGraphicsSurface* self) {
	gint result;
	SDL_Surface* _tmp0_;
	gint _tmp1_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->surface;
	_tmp1_ = _tmp0_->h;
	result = _tmp1_;
	return result;
}


void sdx_graphics_surface_cached_surface_Initialize (gint size) {
	SdxGraphicsSurface** _tmp0_;
	gint _tmp0__length1;
	_tmp0_ = sdx_graphics_surface_cached_surface_cache;
	_tmp0__length1 = sdx_graphics_surface_cached_surface_cache_length1;
	if (_tmp0__length1 == 0) {
		gint _tmp1_;
		SdxGraphicsSurface** _tmp2_;
		_tmp1_ = size;
		_tmp2_ = g_new0 (SdxGraphicsSurface*, _tmp1_ + 1);
		sdx_graphics_surface_cached_surface_cache = (_vala_array_free (sdx_graphics_surface_cached_surface_cache, sdx_graphics_surface_cached_surface_cache_length1, (GDestroyNotify) sdx_graphics_surface_release), NULL);
		sdx_graphics_surface_cached_surface_cache = _tmp2_;
		sdx_graphics_surface_cached_surface_cache_length1 = _tmp1_;
	}
}


SdxGraphicsSurfaceCachedSurface* sdx_graphics_surface_cached_surface_new (SdxFilesFileHandle* file) {
	SdxGraphicsSurfaceCachedSurface* self;
	gchar* ext = NULL;
	SdxFilesFileHandle* _tmp0_;
	gchar* _tmp1_;
	SDL_RWops* raw = NULL;
	SdxFilesFileHandle* _tmp2_;
	SDL_RWops* _tmp3_;
	SdxFilesFileHandle* _tmp4_;
	gchar* _tmp5_;
	SDL_Surface* _tmp6_;
	SDL_Surface* _tmp7_;
	g_return_val_if_fail (file != NULL, NULL);
	self = (SdxGraphicsSurfaceCachedSurface*) sdx_graphics_surface_new ();
	_tmp0_ = file;
	_tmp1_ = sdx_files_file_handle_GetExt (_tmp0_);
	ext = _tmp1_;
	_tmp2_ = file;
	_tmp3_ = sdx_files_file_handle_GetRWops (_tmp2_);
	raw = _tmp3_;
	_tmp4_ = file;
	_tmp5_ = sdx_files_file_handle_GetPath (_tmp4_);
	_g_free0 (((SdxGraphicsSurface*) self)->path);
	((SdxGraphicsSurface*) self)->path = _tmp5_;
	_tmp6_ = sdx_graphics_surface_GetSurface ((SdxGraphicsSurface*) self, ext, raw);
	_SDL_FreeSurface0 (((SdxGraphicsSurface*) self)->surface);
	((SdxGraphicsSurface*) self)->surface = _tmp6_;
	_tmp7_ = ((SdxGraphicsSurface*) self)->surface;
	SDL_SetSurfaceAlphaMod (_tmp7_, (guint8) 0xff);
	_SDL_FreeRW0 (raw);
	_g_free0 (ext);
	return self;
}


gint sdx_graphics_surface_cached_surface_IndexOfPath (const gchar* path) {
	gint result = 0;
	SdxGraphicsSurface** _tmp0_;
	gint _tmp0__length1;
	GError* _tmp21_;
	gint _tmp22_ = 0;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (path != NULL, 0);
	_tmp0_ = sdx_graphics_surface_cached_surface_cache;
	_tmp0__length1 = sdx_graphics_surface_cached_surface_cache_length1;
	if (_tmp0__length1 == 0) {
		SdxGraphicsSurface** _tmp1_;
		_tmp1_ = g_new0 (SdxGraphicsSurface*, 10 + 1);
		sdx_graphics_surface_cached_surface_cache = (_vala_array_free (sdx_graphics_surface_cached_surface_cache, sdx_graphics_surface_cached_surface_cache_length1, (GDestroyNotify) sdx_graphics_surface_release), NULL);
		sdx_graphics_surface_cached_surface_cache = _tmp1_;
		sdx_graphics_surface_cached_surface_cache_length1 = 10;
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gint _tmp4_;
				SdxGraphicsSurface** _tmp5_;
				gint _tmp5__length1;
				SdxGraphicsSurface** _tmp6_;
				gint _tmp6__length1;
				gint _tmp7_;
				SdxGraphicsSurface* _tmp8_;
				SdxGraphicsSurface** _tmp16_;
				gint _tmp16__length1;
				gint _tmp17_;
				SdxGraphicsSurface* _tmp18_;
				const gchar* _tmp19_;
				const gchar* _tmp20_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = i;
				_tmp5_ = sdx_graphics_surface_cached_surface_cache;
				_tmp5__length1 = sdx_graphics_surface_cached_surface_cache_length1;
				if (!(_tmp4_ < _tmp5__length1)) {
					break;
				}
				_tmp6_ = sdx_graphics_surface_cached_surface_cache;
				_tmp6__length1 = sdx_graphics_surface_cached_surface_cache_length1;
				_tmp7_ = i;
				_tmp8_ = _tmp6_[_tmp7_];
				if (_tmp8_ == NULL) {
					SdxGraphicsSurface** _tmp9_;
					gint _tmp9__length1;
					gint _tmp10_;
					const gchar* _tmp11_;
					SdxFilesFileHandle* _tmp12_;
					SdxFilesFileHandle* _tmp13_;
					SdxGraphicsSurfaceCachedSurface* _tmp14_;
					SdxGraphicsSurface* _tmp15_;
					_tmp9_ = sdx_graphics_surface_cached_surface_cache;
					_tmp9__length1 = sdx_graphics_surface_cached_surface_cache_length1;
					_tmp10_ = i;
					_tmp11_ = path;
					_tmp12_ = sdx_files_Default (_tmp11_);
					_tmp13_ = _tmp12_;
					_tmp14_ = sdx_graphics_surface_cached_surface_new (_tmp13_);
					_sdx_graphics_surface_release0 (_tmp9_[_tmp10_]);
					_tmp9_[_tmp10_] = (SdxGraphicsSurface*) _tmp14_;
					_tmp15_ = _tmp9_[_tmp10_];
					_sdx_files_file_handle_release0 (_tmp13_);
					result = i;
					return result;
				}
				_tmp16_ = sdx_graphics_surface_cached_surface_cache;
				_tmp16__length1 = sdx_graphics_surface_cached_surface_cache_length1;
				_tmp17_ = i;
				_tmp18_ = _tmp16_[_tmp17_];
				_tmp19_ = _tmp18_->path;
				_tmp20_ = path;
				if (g_strcmp0 (_tmp19_, _tmp20_) == 0) {
					result = i;
					return result;
				}
			}
		}
	}
	_tmp21_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_UnableToLoadSurface, "Cache is full");
	_inner_error_ = _tmp21_;
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
	g_clear_error (&_inner_error_);
	return _tmp22_;
}


SdxGraphicsSurfaceTextureSurface* sdx_graphics_surface_texture_surface_new (SdxFilesFileHandle* file) {
	SdxGraphicsSurfaceTextureSurface* self;
	SdxFilesFileHandle* _tmp0_;
	gchar* _tmp1_;
	SDL_RWops* raw = NULL;
	SdxFilesFileHandle* _tmp2_;
	SDL_RWops* _tmp3_;
	SdxFilesFileHandle* _tmp4_;
	gchar* _tmp5_;
	gchar* _tmp6_;
	SDL_Surface* _tmp7_;
	SDL_Surface* _tmp8_;
	g_return_val_if_fail (file != NULL, NULL);
	self = (SdxGraphicsSurfaceTextureSurface*) sdx_graphics_surface_new ();
	_tmp0_ = file;
	_tmp1_ = sdx_files_file_handle_GetPath (_tmp0_);
	_g_free0 (((SdxGraphicsSurface*) self)->path);
	((SdxGraphicsSurface*) self)->path = _tmp1_;
	_tmp2_ = file;
	_tmp3_ = sdx_files_file_handle_GetRWops (_tmp2_);
	raw = _tmp3_;
	_tmp4_ = file;
	_tmp5_ = sdx_files_file_handle_GetExt (_tmp4_);
	_tmp6_ = _tmp5_;
	_tmp7_ = sdx_graphics_surface_GetSurface ((SdxGraphicsSurface*) self, _tmp6_, raw);
	_SDL_FreeSurface0 (((SdxGraphicsSurface*) self)->surface);
	((SdxGraphicsSurface*) self)->surface = _tmp7_;
	_g_free0 (_tmp6_);
	_tmp8_ = ((SdxGraphicsSurface*) self)->surface;
	SDL_SetSurfaceAlphaMod (_tmp8_, (guint8) 0xff);
	_SDL_FreeRW0 (raw);
	return self;
}


void sdx_graphics_surface_texture_surface_SetFilter (SdxGraphicsSurfaceTextureSurface* self, gint minFilter, gint magFilter) {
	g_return_if_fail (self != NULL);
}


void sdx_graphics_surface_texture_surface_SetWrap (SdxGraphicsSurfaceTextureSurface* self, gint u, gint v) {
	g_return_if_fail (self != NULL);
}


static void sdx_graphics_surface_instance_init (SdxGraphicsSurface * self) {
	gint _tmp0_;
	gint _tmp1_;
	self->ref_count = 1;
	_tmp0_ = sdx_graphics_surface_uniqueId;
	sdx_graphics_surface_uniqueId = _tmp0_ + 1;
	_tmp1_ = sdx_graphics_surface_uniqueId;
	self->id = _tmp1_;
}


void sdx_graphics_surface_free (SdxGraphicsSurface * self) {
	_SDL_FreeSurface0 (self->surface);
	_g_free0 (self->path);
	g_slice_free (SdxGraphicsSurface, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}





/** updated by adriac */
/* sdx.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from sdx.vala, do not modify */

/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <SDL_events.h>
#include <SDL_video.h>
#include <SDL_render.h>
#include <SDL_pixels.h>
#include <stdlib.h>
#include <string.h>
#include <SDL.h>
#include <SDL_image.h>
#include <SDL_hints.h>
#include <SDL_ttf.h>
#include <SDL_mixer.h>
#include <SDL_audio.h>
#include <SDL_timer.h>
#include "mt19937ar.h"
#include <SDL_rect.h>
#include <SDL_keyboard.h>
#include <stdio.h>


#define SDX_TYPE_FILE_TYPE (sdx_file_type_get_type ())
typedef struct _SdxFont SdxFont;
typedef struct _SdxGraphicsTextureAtlas SdxGraphicsTextureAtlas;
typedef struct _SdxUiComponent SdxUiComponent;
typedef SdxUiComponent SdxUiWindow;
typedef struct _SdxInputMultiplexer SdxInputMultiplexer;
typedef struct _SdxMathTweenManager SdxMathTweenManager;
#define _g_free0(var) ((var == NULL) ? NULL : (var = (g_free (var), NULL)))
#define _SDL_DestroyWindow0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyWindow (var), NULL)))
#define _SDL_DestroyRenderer0(var) ((var == NULL) ? NULL : (var = (SDL_DestroyRenderer (var), NULL)))
// symtbl.1 sdx_input_multiplexer
void sdx_input_multiplexer_release (SdxInputMultiplexer* self);
void sdx_input_multiplexer_free (SdxInputMultiplexer* self);
SdxInputMultiplexer* sdx_input_multiplexer_retain (SdxInputMultiplexer* self);
#define _sdx_input_multiplexer_release0(var) ((var == NULL) ? NULL : (var = (sdx_input_multiplexer_release (var), NULL)))
typedef struct _SdxFilesFileHandle SdxFilesFileHandle;
// symtbl.1 sdx_graphics_texture_atlas
void sdx_graphics_texture_atlas_release (SdxGraphicsTextureAtlas* self);
void sdx_graphics_texture_atlas_free (SdxGraphicsTextureAtlas* self);
SdxGraphicsTextureAtlas* sdx_graphics_texture_atlas_retain (SdxGraphicsTextureAtlas* self);
#define _sdx_graphics_texture_atlas_release0(var) ((var == NULL) ? NULL : (var = (sdx_graphics_texture_atlas_release (var), NULL)))
// symtbl.1 sdx_files_file_handle
void sdx_files_file_handle_release (SdxFilesFileHandle* self);
void sdx_files_file_handle_free (SdxFilesFileHandle* self);
SdxFilesFileHandle* sdx_files_file_handle_retain (SdxFilesFileHandle* self);
#define _sdx_files_file_handle_release0(var) ((var == NULL) ? NULL : (var = (sdx_files_file_handle_release (var), NULL)))
// symtbl.1 sdx_math_tween_manager
void sdx_math_tween_manager_release (SdxMathTweenManager* self);
void sdx_math_tween_manager_free (SdxMathTweenManager* self);
SdxMathTweenManager* sdx_math_tween_manager_retain (SdxMathTweenManager* self);
#define _sdx_math_tween_manager_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tween_manager_release (var), NULL)))
typedef struct _SdxInputProcessor SdxInputProcessor;
// symtbl.1 sdx_font
void sdx_font_release (SdxFont* self);
void sdx_font_free (SdxFont* self);
SdxFont* sdx_font_retain (SdxFont* self);
#define _sdx_font_release0(var) ((var == NULL) ? NULL : (var = (sdx_font_release (var), NULL)))
typedef struct _SdxAbstractGame SdxAbstractGame;

typedef enum  {
	SDX_FILE_TYPE_Resource = 1,
	SDX_FILE_TYPE_Asset,
	SDX_FILE_TYPE_Absolute,
	SDX_FILE_TYPE_Relative
} SdxFileType;

typedef enum  {
	SDX_SDL_EXCEPTION_Initialization,
	SDX_SDL_EXCEPTION_ImageInitialization,
	SDX_SDL_EXCEPTION_TtfInitialization,
	SDX_SDL_EXCEPTION_TextureFilteringNotEnabled,
	SDX_SDL_EXCEPTION_OpenWindow,
	SDX_SDL_EXCEPTION_CreateRenderer,
	SDX_SDL_EXCEPTION_InvalidForPlatform,
	SDX_SDL_EXCEPTION_UnableToLoadResource,
	SDX_SDL_EXCEPTION_UnableToLoadSurface,
	SDX_SDL_EXCEPTION_UnableToLoadTexture,
	SDX_SDL_EXCEPTION_NullPointer,
	SDX_SDL_EXCEPTION_NoSuchElement,
	SDX_SDL_EXCEPTION_IllegalStateException,
	SDX_SDL_EXCEPTION_IllegalArgumentException,
	SDX_SDL_EXCEPTION_RuntimeException,
	SDX_SDL_EXCEPTION_NotReached
} SdxSdlException;
#define SDX_SDL_EXCEPTION sdx_sdl_exception_quark ()
typedef void (*SdxAbstractGameAbstractUpdate) (void* user_data);
typedef void (*SdxAbstractGameAbstractDraw) (void* user_data);
struct _SdxAbstractGame {
	gint ref_count;
	gint width;
	gint height;
	SdxAbstractGameAbstractUpdate Update;
	gpointer Update_target;
	GDestroyNotify Update_target_destroy_notify;
	SdxAbstractGameAbstractDraw Draw;
	gpointer Draw_target;
	GDestroyNotify Draw_target_destroy_notify;
};


extern SdxFileType sdx_platform;
SdxFileType sdx_platform = SDX_FILE_TYPE_Relative;
extern SDL_Event sdx_evt;
SDL_Event sdx_evt = {0};
extern SDL_DisplayMode sdx_displayMode;
SDL_DisplayMode sdx_displayMode = {0};
extern SDL_Renderer* sdx_renderer;
SDL_Renderer* sdx_renderer = NULL;
extern int* sdx_display;
int* sdx_display = NULL;
extern SDL_Color* sdx_bgdColor;
SDL_Color* sdx_bgdColor = NULL;
extern SdxFont* sdx_font;
SdxFont* sdx_font = NULL;
extern SdxFont* sdx_smallFont;
SdxFont* sdx_smallFont = NULL;
extern SdxFont* sdx_largeFont;
SdxFont* sdx_largeFont = NULL;
extern SdxGraphicsTextureAtlas* sdx_atlas;
SdxGraphicsTextureAtlas* sdx_atlas = NULL;
extern SdxUiWindow* sdx_ui;
SdxUiWindow* sdx_ui = NULL;
extern SdxInputMultiplexer* sdx_inputProcessor;
SdxInputMultiplexer* sdx_inputProcessor = NULL;
extern SdxMathTweenManager* sdx_tweenManager;
SdxMathTweenManager* sdx_tweenManager = NULL;
extern gfloat sdx_fps;
gfloat sdx_fps = 60.f;
extern gfloat sdx_delta;
gfloat sdx_delta = 1.0f / 60.0f;
extern gboolean sdx_running;
gboolean sdx_running = FALSE;
extern gchar* sdx_resourceBase;
gchar* sdx_resourceBase = NULL;
extern gdouble sdx_currentTime;
gdouble sdx_currentTime = 0.0;
extern gdouble sdx_accumulator;
gdouble sdx_accumulator = 0.0;
extern gdouble sdx_freq;
gdouble sdx_freq = 0.0;
extern gint sdx_width;
gint sdx_width = 0;
extern gint sdx_height;
gint sdx_height = 0;

#define SDX_MS_PER_UPDATE (1.0 / 60.0)
#define SDX_pixelFactor 1
GType sdx_file_type_get_type (void) G_GNUC_CONST;
void sdx_font_free (SdxFont * self);
void sdx_graphics_texture_atlas_free (SdxGraphicsTextureAtlas * self);
void sdx_ui_component_free (SdxUiComponent * self);
void sdx_input_multiplexer_free (SdxInputMultiplexer * self);
void sdx_math_tween_manager_free (SdxMathTweenManager * self);
SDL_Window* sdx_Initialize (gint width, gint height, const gchar* name);
GQuark sdx_sdl_exception_quark (void);
static int* _sdl_video_display_dup (int* self);
static SDL_Color* _sdl_video_color_dup (SDL_Color* self);
SdxInputMultiplexer* sdx_input_multiplexer_new (void);
gint sdx_Render (SDL_Texture* texture, SDL_Rect* srcrect, SDL_Rect* dstrect);
gdouble sdx_GetRandom (void);
void sdx_SetAtlas (const gchar* path);
void sdx_files_file_handle_free (SdxFilesFileHandle * self);
SdxFilesFileHandle* sdx_files_Default (const gchar* path);
SdxGraphicsTextureAtlas* sdx_graphics_texture_atlas_new (SdxFilesFileHandle* packFile, SdxFilesFileHandle* imageDir, gboolean flip);
void sdx_SetTweenManager (SdxMathTweenManager* manager);
void sdx_input_processor_free (SdxInputProcessor * self);
void sdx_AddInputProcessor (SdxInputProcessor* processor);
void sdx_input_multiplexer_Add (SdxInputMultiplexer* self, SdxInputProcessor* processor);
void sdx_RemoveInputProcessor (SdxInputProcessor* processor);
void sdx_input_multiplexer_Remove (SdxInputMultiplexer* self, SdxInputProcessor* processor);
void sdx_SetResourceBase (const gchar* path);
void sdx_SetDefaultFont (const gchar* path, gint size);
SdxFont* sdx_font_new (const gchar* path, gint size);
void sdx_SetSmallFont (const gchar* path, gint size);
void sdx_SetLargeFont (const gchar* path, gint size);
gdouble sdx_GetNow (void);
void sdx_Start (void);
void sdx_abstract_game_free (SdxAbstractGame * self);
void sdx_GameLoop (SdxAbstractGame* game);
void sdx_ProcessEvents (void);
void sdx_math_tween_manager_Update (SdxMathTweenManager* self, gfloat delta);
gboolean sdx_input_multiplexer_KeyDown (SdxInputMultiplexer* self, gint keycode);
gboolean sdx_input_multiplexer_KeyUp (SdxInputMultiplexer* self, gint keycode);
gboolean sdx_input_multiplexer_MouseMoved (SdxInputMultiplexer* self, gint x, gint y);
gboolean sdx_input_multiplexer_TouchDown (SdxInputMultiplexer* self, gint x, gint y, gint pointer, gint button);
gboolean sdx_input_multiplexer_TouchUp (SdxInputMultiplexer* self, gint x, gint y, gint pointer, gint button);
gboolean sdx_input_multiplexer_TouchDragged (SdxInputMultiplexer* self, gint x, gint y, gint pointer);
void sdx_Begin (void);
void sdx_End (void);
void sdx_Log (const gchar* text);

extern const SDL_Color SDX_COLOR_Black;

/**
 * Initialization
 * 
 */
static int* _sdl_video_display_dup (int* self) {
	int* dup;
	dup = g_new0 (int, 1);
	memcpy (dup, self, sizeof (int));
	return dup;
}


static gpointer __sdl_video_display_dup0 (gpointer self) {
	return self ? _sdl_video_display_dup (self) : NULL;
}


static SDL_Color* _sdl_video_color_dup (SDL_Color* self) {
	SDL_Color* dup;
	dup = g_new0 (SDL_Color, 1);
	memcpy (dup, self, sizeof (SDL_Color));
	return dup;
}


static gpointer __sdl_video_color_dup0 (gpointer self) {
	return self ? _sdl_video_color_dup (self) : NULL;
}


SDL_Window* sdx_Initialize (gint width, gint height, const gchar* name) {
	SDL_Window* result = NULL;
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gint _tmp6_;
	gboolean _tmp9_;
	gint _tmp12_;
	gint _tmp15_;
	int _tmp17_;
	int* _tmp18_;
	int* _tmp19_;
	SDL_DisplayMode _tmp20_ = {0};
	SDL_Window* window = NULL;
	const gchar* _tmp21_;
	gint _tmp22_;
	gint _tmp23_;
	SDL_Window* _tmp24_;
	SDL_Window* _tmp25_;
	SDL_Window* _tmp28_;
	SDL_Renderer* _tmp29_;
	SDL_Renderer* _tmp30_;
	guint64 _tmp33_;
	SDL_Color _tmp34_;
	SDL_Color* _tmp35_;
	guint64 _tmp36_;
	SdxInputMultiplexer* _tmp37_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = name;
	g_print ("How did I get here? %s\n", _tmp0_);
	_tmp1_ = height;
	sdx_height = _tmp1_;
	_tmp2_ = width;
	sdx_width = _tmp2_;
	_tmp3_ = SDL_Init ((guint32) ((SDL_INIT_VIDEO | SDL_INIT_TIMER) | SDL_INIT_EVENTS));
	if (_tmp3_ < 0) {
		const gchar* _tmp4_;
		GError* _tmp5_;
		_tmp4_ = SDL_GetError ();
		_tmp5_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_Initialization, _tmp4_);
		_inner_error_ = _tmp5_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp6_ = IMG_Init ((gint) IMG_INIT_PNG);
	if (_tmp6_ < 0) {
		const gchar* _tmp7_;
		GError* _tmp8_;
		_tmp7_ = SDL_GetError ();
		_tmp8_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_ImageInitialization, _tmp7_);
		_inner_error_ = _tmp8_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp9_ = SDL_SetHint (SDL_HINT_RENDER_SCALE_QUALITY, "1");
	if (!_tmp9_) {
		const gchar* _tmp10_;
		GError* _tmp11_;
		_tmp10_ = SDL_GetError ();
		_tmp11_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_TextureFilteringNotEnabled, _tmp10_);
		_inner_error_ = _tmp11_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp12_ = TTF_Init ();
	if (_tmp12_ == -1) {
		const gchar* _tmp13_;
		GError* _tmp14_;
		_tmp13_ = SDL_GetError ();
		_tmp14_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_TtfInitialization, _tmp13_);
		_inner_error_ = _tmp14_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp15_ = Mix_OpenAudio (22050, AUDIO_S16LSB, 2, 4096);
	if (_tmp15_ == -1) {
		const gchar* _tmp16_;
		_tmp16_ = SDL_GetError ();
		g_print ("SDL_mixer unagle to initialize! SDL Error: %s\n", _tmp16_);
	}
	_tmp17_ = (int) 0;
	_tmp18_ = __sdl_video_display_dup0 (&_tmp17_);
	_g_free0 (sdx_display);
	sdx_display = _tmp18_;
	_tmp19_ = sdx_display;
	SDL_GetDisplayMode (*_tmp19_, 0, &_tmp20_);
	 (&sdx_displayMode);
	sdx_displayMode = _tmp20_;
	_tmp21_ = name;
	_tmp22_ = width;
	_tmp23_ = height;
	_tmp24_ = SDL_CreateWindow (_tmp21_, (gint) SDL_WINDOWPOS_CENTERED_MASK, (gint) SDL_WINDOWPOS_CENTERED_MASK, _tmp22_, _tmp23_, (guint32) SDL_WINDOW_SHOWN);
	window = _tmp24_;
	_tmp25_ = window;
	if (_tmp25_ == NULL) {
		const gchar* _tmp26_;
		GError* _tmp27_;
		_tmp26_ = SDL_GetError ();
		_tmp27_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_OpenWindow, _tmp26_);
		_inner_error_ = _tmp27_;
		_SDL_DestroyWindow0 (window);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp28_ = window;
	_tmp29_ = SDL_CreateRenderer (_tmp28_, -1, (guint32) (SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC));
	_SDL_DestroyRenderer0 (sdx_renderer);
	sdx_renderer = _tmp29_;
	_tmp30_ = sdx_renderer;
	if (_tmp30_ == NULL) {
		const gchar* _tmp31_;
		GError* _tmp32_;
		_tmp31_ = SDL_GetError ();
		_tmp32_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_CreateRenderer, _tmp31_);
		_inner_error_ = _tmp32_;
		_SDL_DestroyWindow0 (window);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp33_ = SDL_GetPerformanceFrequency ();
	sdx_freq = (gdouble) _tmp33_;
	_tmp34_ = SDX_COLOR_Black;
	_tmp35_ = __sdl_video_color_dup0 (&_tmp34_);
	_g_free0 (sdx_bgdColor);
	sdx_bgdColor = _tmp35_;
	_tmp36_ = SDL_GetPerformanceCounter ();
	init_genrand ((gulong) _tmp36_);
	_tmp37_ = sdx_input_multiplexer_new ();
	_sdx_input_multiplexer_release0 (sdx_inputProcessor);
	sdx_inputProcessor = _tmp37_;
	result = window;
	return result;
}


gint sdx_Render (SDL_Texture* texture, SDL_Rect* srcrect, SDL_Rect* dstrect) {
	gint result = 0;
	SDL_Renderer* _tmp0_;
	SDL_Texture* _tmp1_;
	SDL_Rect* _tmp2_;
	SDL_Rect* _tmp3_;
	gint _tmp4_;
	g_return_val_if_fail (texture != NULL, 0);
	_tmp0_ = sdx_renderer;
	_tmp1_ = texture;
	_tmp2_ = srcrect;
	_tmp3_ = dstrect;
	_tmp4_ = SDL_RenderCopy (_tmp0_, _tmp1_, _tmp2_, _tmp3_);
	result = _tmp4_;
	return result;
}


gdouble sdx_GetRandom (void) {
	gdouble result = 0.0;
	gdouble _tmp0_;
	_tmp0_ = genrand_real2 ();
	result = _tmp0_;
	return result;
}


void sdx_SetAtlas (const gchar* path) {
	const gchar* _tmp0_;
	SdxFilesFileHandle* _tmp1_;
	SdxFilesFileHandle* _tmp2_;
	SdxGraphicsTextureAtlas* _tmp3_;
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = sdx_files_Default (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = sdx_graphics_texture_atlas_new (_tmp2_, NULL, FALSE);
	_sdx_graphics_texture_atlas_release0 (sdx_atlas);
	sdx_atlas = _tmp3_;
	_sdx_files_file_handle_release0 (_tmp2_);
}


static gpointer _sdx_math_tween_manager_retain0 (gpointer self) {
	return self ? sdx_math_tween_manager_retain (self) : NULL;
}


void sdx_SetTweenManager (SdxMathTweenManager* manager) {
	SdxMathTweenManager* _tmp0_;
	SdxMathTweenManager* _tmp1_;
	g_return_if_fail (manager != NULL);
	_tmp0_ = manager;
	_tmp1_ = _sdx_math_tween_manager_retain0 (_tmp0_);
	_sdx_math_tween_manager_release0 (sdx_tweenManager);
	sdx_tweenManager = _tmp1_;
}


void sdx_AddInputProcessor (SdxInputProcessor* processor) {
	SdxInputMultiplexer* _tmp0_;
	SdxInputProcessor* _tmp1_;
	g_return_if_fail (processor != NULL);
	_tmp0_ = sdx_inputProcessor;
	_tmp1_ = processor;
	sdx_input_multiplexer_Add (_tmp0_, _tmp1_);
}


void sdx_RemoveInputProcessor (SdxInputProcessor* processor) {
	SdxInputMultiplexer* _tmp0_;
	SdxInputProcessor* _tmp1_;
	g_return_if_fail (processor != NULL);
	_tmp0_ = sdx_inputProcessor;
	_tmp1_ = processor;
	sdx_input_multiplexer_Remove (_tmp0_, _tmp1_);
}


void sdx_SetResourceBase (const gchar* path) {
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (sdx_resourceBase);
	sdx_resourceBase = _tmp1_;
}


void sdx_SetDefaultFont (const gchar* path, gint size) {
	const gchar* _tmp0_;
	gint _tmp1_;
	SdxFont* _tmp2_;
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = size;
	_tmp2_ = sdx_font_new (_tmp0_, _tmp1_);
	_sdx_font_release0 (sdx_font);
	sdx_font = _tmp2_;
}


void sdx_SetSmallFont (const gchar* path, gint size) {
	const gchar* _tmp0_;
	gint _tmp1_;
	SdxFont* _tmp2_;
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = size;
	_tmp2_ = sdx_font_new (_tmp0_, _tmp1_);
	_sdx_font_release0 (sdx_smallFont);
	sdx_smallFont = _tmp2_;
}


void sdx_SetLargeFont (const gchar* path, gint size) {
	const gchar* _tmp0_;
	gint _tmp1_;
	SdxFont* _tmp2_;
	g_return_if_fail (path != NULL);
	_tmp0_ = path;
	_tmp1_ = size;
	_tmp2_ = sdx_font_new (_tmp0_, _tmp1_);
	_sdx_font_release0 (sdx_largeFont);
	sdx_largeFont = _tmp2_;
}


gdouble sdx_GetNow (void) {
	gdouble result = 0.0;
	guint64 _tmp0_;
	gdouble _tmp1_;
	_tmp0_ = SDL_GetPerformanceCounter ();
	_tmp1_ = sdx_freq;
	result = ((gdouble) _tmp0_) / _tmp1_;
	return result;
}


void sdx_Start (void) {
	gdouble _tmp0_;
	_tmp0_ = sdx_GetNow ();
	sdx_currentTime = _tmp0_;
	sdx_running = TRUE;
}


void sdx_GameLoop (SdxAbstractGame* game) {
	gdouble newTime = 0.0;
	gdouble _tmp0_;
	gdouble frameTime = 0.0;
	gdouble _tmp1_;
	gdouble _tmp2_;
	gdouble _tmp3_;
	gdouble _tmp4_;
	gdouble _tmp5_;
	gdouble _tmp6_;
	SdxAbstractGame* _tmp13_;
	SdxAbstractGameAbstractDraw _tmp14_;
	void* _tmp14__target;
	g_return_if_fail (game != NULL);
	_tmp0_ = sdx_GetNow ();
	newTime = _tmp0_;
	_tmp1_ = newTime;
	_tmp2_ = sdx_currentTime;
	frameTime = _tmp1_ - _tmp2_;
	_tmp3_ = frameTime;
	if (_tmp3_ > 0.25) {
		frameTime = 0.25;
	}
	_tmp4_ = newTime;
	sdx_currentTime = _tmp4_;
	_tmp5_ = sdx_accumulator;
	_tmp6_ = frameTime;
	sdx_accumulator = _tmp5_ + _tmp6_;
	sdx_ProcessEvents ();
	while (TRUE) {
		gdouble _tmp7_;
		SdxMathTweenManager* _tmp8_;
		SdxAbstractGame* _tmp10_;
		SdxAbstractGameAbstractUpdate _tmp11_;
		void* _tmp11__target;
		gdouble _tmp12_;
		_tmp7_ = sdx_accumulator;
		if (!(_tmp7_ >= SDX_MS_PER_UPDATE)) {
			break;
		}
		_tmp8_ = sdx_tweenManager;
		if (_tmp8_ != NULL) {
			SdxMathTweenManager* _tmp9_;
			_tmp9_ = sdx_tweenManager;
			sdx_math_tween_manager_Update (_tmp9_, (gfloat) SDX_MS_PER_UPDATE);
		}
		_tmp10_ = game;
		_tmp11_ = _tmp10_->Update;
		_tmp11__target = _tmp10_->Update_target;
		_tmp11_ (_tmp11__target);
		_tmp12_ = sdx_accumulator;
		sdx_accumulator = _tmp12_ - SDX_MS_PER_UPDATE;
	}
	_tmp13_ = game;
	_tmp14_ = _tmp13_->Draw;
	_tmp14__target = _tmp13_->Draw_target;
	_tmp14_ (_tmp14__target);
}


void sdx_ProcessEvents (void) {
	while (TRUE) {
		SDL_Event _tmp0_ = {0};
		gint _tmp1_;
		SDL_Event _tmp2_;
		SDL_EventType _tmp3_;
		_tmp1_ = SDL_PollEvent (&_tmp0_);
		 (sdx_evt);
		sdx_evt = _tmp0_;
		if (!(_tmp1_ != 0)) {
			break;
		}
		_tmp2_ = sdx_evt;
		_tmp3_ = _tmp2_.type;
		switch (_tmp3_) {
			case SDL_QUIT:
			{
				sdx_running = FALSE;
				break;
			}
			case SDL_KEYDOWN:
			{
				gboolean _tmp4_ = FALSE;
				SDL_Event _tmp5_;
				SDL_KeyboardEvent _tmp6_;
				SDL_Keysym _tmp7_;
				SDL_Keycode _tmp8_;
				SdxInputMultiplexer* _tmp13_;
				_tmp5_ = sdx_evt;
				_tmp6_ = _tmp5_.key;
				_tmp7_ = _tmp6_.keysym;
				_tmp8_ = _tmp7_.sym;
				if (_tmp8_ < 0) {
					_tmp4_ = TRUE;
				} else {
					SDL_Event _tmp9_;
					SDL_KeyboardEvent _tmp10_;
					SDL_Keysym _tmp11_;
					SDL_Keycode _tmp12_;
					_tmp9_ = sdx_evt;
					_tmp10_ = _tmp9_.key;
					_tmp11_ = _tmp10_.keysym;
					_tmp12_ = _tmp11_.sym;
					_tmp4_ = _tmp12_ > 255;
				}
				if (_tmp4_) {
					break;
				}
				_tmp13_ = sdx_inputProcessor;
				if (sdx_input_multiplexer_KeyDown != NULL) {
					SdxInputMultiplexer* _tmp14_;
					SDL_Event _tmp15_;
					SDL_KeyboardEvent _tmp16_;
					SDL_Keysym _tmp17_;
					SDL_Keycode _tmp18_;
					_tmp14_ = sdx_inputProcessor;
					_tmp15_ = sdx_evt;
					_tmp16_ = _tmp15_.key;
					_tmp17_ = _tmp16_.keysym;
					_tmp18_ = _tmp17_.sym;
					sdx_input_multiplexer_KeyDown (_tmp14_, (gint) _tmp18_);
				}
				break;
			}
			case SDL_KEYUP:
			{
				gboolean _tmp19_ = FALSE;
				SDL_Event _tmp20_;
				SDL_KeyboardEvent _tmp21_;
				SDL_Keysym _tmp22_;
				SDL_Keycode _tmp23_;
				SdxInputMultiplexer* _tmp28_;
				_tmp20_ = sdx_evt;
				_tmp21_ = _tmp20_.key;
				_tmp22_ = _tmp21_.keysym;
				_tmp23_ = _tmp22_.sym;
				if (_tmp23_ < 0) {
					_tmp19_ = TRUE;
				} else {
					SDL_Event _tmp24_;
					SDL_KeyboardEvent _tmp25_;
					SDL_Keysym _tmp26_;
					SDL_Keycode _tmp27_;
					_tmp24_ = sdx_evt;
					_tmp25_ = _tmp24_.key;
					_tmp26_ = _tmp25_.keysym;
					_tmp27_ = _tmp26_.sym;
					_tmp19_ = _tmp27_ > 255;
				}
				if (_tmp19_) {
					break;
				}
				_tmp28_ = sdx_inputProcessor;
				if (sdx_input_multiplexer_KeyUp != NULL) {
					SdxInputMultiplexer* _tmp29_;
					SDL_Event _tmp30_;
					SDL_KeyboardEvent _tmp31_;
					SDL_Keysym _tmp32_;
					SDL_Keycode _tmp33_;
					_tmp29_ = sdx_inputProcessor;
					_tmp30_ = sdx_evt;
					_tmp31_ = _tmp30_.key;
					_tmp32_ = _tmp31_.keysym;
					_tmp33_ = _tmp32_.sym;
					sdx_input_multiplexer_KeyUp (_tmp29_, (gint) _tmp33_);
				}
				break;
			}
			case SDL_MOUSEMOTION:
			{
				SdxInputMultiplexer* _tmp34_;
				_tmp34_ = sdx_inputProcessor;
				if (sdx_input_multiplexer_MouseMoved != NULL) {
					SdxInputMultiplexer* _tmp35_;
					SDL_Event _tmp36_;
					SDL_MouseMotionEvent _tmp37_;
					gint32 _tmp38_;
					SDL_Event _tmp39_;
					SDL_MouseMotionEvent _tmp40_;
					gint32 _tmp41_;
					_tmp35_ = sdx_inputProcessor;
					_tmp36_ = sdx_evt;
					_tmp37_ = _tmp36_.motion;
					_tmp38_ = _tmp37_.x;
					_tmp39_ = sdx_evt;
					_tmp40_ = _tmp39_.motion;
					_tmp41_ = _tmp40_.y;
					sdx_input_multiplexer_MouseMoved (_tmp35_, (gint) _tmp38_, (gint) _tmp41_);
				}
				break;
			}
			case SDL_MOUSEBUTTONDOWN:
			{
				SdxInputMultiplexer* _tmp42_;
				_tmp42_ = sdx_inputProcessor;
				if (sdx_input_multiplexer_TouchDown != NULL) {
					SdxInputMultiplexer* _tmp43_;
					SDL_Event _tmp44_;
					SDL_MouseMotionEvent _tmp45_;
					gint32 _tmp46_;
					SDL_Event _tmp47_;
					SDL_MouseMotionEvent _tmp48_;
					gint32 _tmp49_;
					gboolean _tmp50_;
					_tmp43_ = sdx_inputProcessor;
					_tmp44_ = sdx_evt;
					_tmp45_ = _tmp44_.motion;
					_tmp46_ = _tmp45_.x;
					_tmp47_ = sdx_evt;
					_tmp48_ = _tmp47_.motion;
					_tmp49_ = _tmp48_.y;
					_tmp50_ = sdx_input_multiplexer_TouchDown (_tmp43_, (gint) _tmp46_, (gint) _tmp49_, 0, 0);
					if (_tmp50_) {
						return;
					}
				}
				break;
			}
			case SDL_MOUSEBUTTONUP:
			{
				SdxInputMultiplexer* _tmp51_;
				_tmp51_ = sdx_inputProcessor;
				if (sdx_input_multiplexer_TouchUp != NULL) {
					SdxInputMultiplexer* _tmp52_;
					SDL_Event _tmp53_;
					SDL_MouseMotionEvent _tmp54_;
					gint32 _tmp55_;
					SDL_Event _tmp56_;
					SDL_MouseMotionEvent _tmp57_;
					gint32 _tmp58_;
					gboolean _tmp59_;
					_tmp52_ = sdx_inputProcessor;
					_tmp53_ = sdx_evt;
					_tmp54_ = _tmp53_.motion;
					_tmp55_ = _tmp54_.x;
					_tmp56_ = sdx_evt;
					_tmp57_ = _tmp56_.motion;
					_tmp58_ = _tmp57_.y;
					_tmp59_ = sdx_input_multiplexer_TouchUp (_tmp52_, (gint) _tmp55_, (gint) _tmp58_, 0, 0);
					if (_tmp59_) {
						return;
					}
				}
				break;
			}
//			case SDL_FINGERMOTION:
//			{
//				SdxInputMultiplexer* _tmp60_;
//				_tmp60_ = sdx_inputProcessor;
//				if (sdx_input_multiplexer_TouchDragged != NULL) {
//					SdxInputMultiplexer* _tmp61_;
//					SDL_Event _tmp62_;
//					SDL_TouchFingerEvent _tmp63_;
//					gfloat _tmp64_;
//					SDL_Event _tmp65_;
//					SDL_TouchFingerEvent _tmp66_;
//					gfloat _tmp67_;
//					_tmp61_ = sdx_inputProcessor;
//					_tmp62_ = sdx_evt;
//					_tmp63_ = _tmp62_.tfinger;
//					_tmp64_ = _tmp63_.x;
//					_tmp65_ = sdx_evt;
//					_tmp66_ = _tmp65_.tfinger;
//					_tmp67_ = _tmp66_.y;
//					sdx_input_multiplexer_TouchDragged (_tmp61_, (gint) _tmp64_, (gint) _tmp67_, 0);
//				}
//				break;
//			}
//			case SDL_FINGERDOWN:
//			{
//				SdxInputMultiplexer* _tmp68_;
//				_tmp68_ = sdx_inputProcessor;
//				if (sdx_input_multiplexer_TouchDown != NULL) {
//					SdxInputMultiplexer* _tmp69_;
//					SDL_Event _tmp70_;
//					SDL_TouchFingerEvent _tmp71_;
//					gfloat _tmp72_;
//					SDL_Event _tmp73_;
//					SDL_TouchFingerEvent _tmp74_;
//					gfloat _tmp75_;
//					_tmp69_ = sdx_inputProcessor;
//					_tmp70_ = sdx_evt;
//					_tmp71_ = _tmp70_.tfinger;
//					_tmp72_ = _tmp71_.x;
//					_tmp73_ = sdx_evt;
//					_tmp74_ = _tmp73_.tfinger;
//					_tmp75_ = _tmp74_.y;
//					sdx_input_multiplexer_TouchDown (_tmp69_, (gint) _tmp72_, (gint) _tmp75_, 0, 0);
//				}
//				break;
//			}
//			case SDL_FINGERUP:
//			{
//				SdxInputMultiplexer* _tmp76_;
//				_tmp76_ = sdx_inputProcessor;
//				if (sdx_input_multiplexer_TouchUp != NULL) {
//					SdxInputMultiplexer* _tmp77_;
//					SDL_Event _tmp78_;
//					SDL_TouchFingerEvent _tmp79_;
//					gfloat _tmp80_;
//					SDL_Event _tmp81_;
//					SDL_TouchFingerEvent _tmp82_;
//					gfloat _tmp83_;
//					_tmp77_ = sdx_inputProcessor;
//					_tmp78_ = sdx_evt;
//					_tmp79_ = _tmp78_.tfinger;
//					_tmp80_ = _tmp79_.x;
//					_tmp81_ = sdx_evt;
//					_tmp82_ = _tmp81_.tfinger;
//					_tmp83_ = _tmp82_.y;
//					sdx_input_multiplexer_TouchUp (_tmp77_, (gint) _tmp80_, (gint) _tmp83_, 0, 0);
//				}
//				break;
//			}
			default:
			break;
		}
	}
}


void sdx_Begin (void) {
	SDL_Renderer* _tmp0_;
	SDL_Color* _tmp1_;
	guint8 _tmp2_;
	SDL_Color* _tmp3_;
	guint8 _tmp4_;
	SDL_Color* _tmp5_;
	guint8 _tmp6_;
	SDL_Color* _tmp7_;
	guint8 _tmp8_;
	SDL_Renderer* _tmp9_;
	_tmp0_ = sdx_renderer;
	_tmp1_ = sdx_bgdColor;
	_tmp2_ = (*_tmp1_).r;
	_tmp3_ = sdx_bgdColor;
	_tmp4_ = (*_tmp3_).g;
	_tmp5_ = sdx_bgdColor;
	_tmp6_ = (*_tmp5_).b;
	_tmp7_ = sdx_bgdColor;
	_tmp8_ = (*_tmp7_).a;
	SDL_SetRenderDrawColor (_tmp0_, _tmp2_, _tmp4_, _tmp6_, _tmp8_);
	_tmp9_ = sdx_renderer;
	SDL_RenderClear (_tmp9_);
}


void sdx_End (void) {
	SDL_Renderer* _tmp0_;
	_tmp0_ = sdx_renderer;
	SDL_RenderPresent (_tmp0_);
}


void sdx_Log (const gchar* text) {
	FILE* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (text != NULL);
	_tmp0_ = stdout;
	_tmp1_ = text;
	fprintf (_tmp0_, "%s\n", _tmp1_);
}





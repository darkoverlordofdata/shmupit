/** updated by adriac */
/* Vector2.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Vector2.vala, do not modify */

/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <string.h>


#define SDX_MATH_TYPE_SCALE (sdx_math_scale_get_type ())
typedef struct _SdxMathScale SdxMathScale;

#define SDX_MATH_TYPE_POINT2 (sdx_math_point2_get_type ())
typedef struct _SdxMathPoint2 SdxMathPoint2;

#define SDX_MATH_TYPE_VECTOR2 (sdx_math_vector2_get_type ())
typedef struct _SdxMathVector2 SdxMathVector2;

struct _SdxMathScale {
	gfloat x;
	gfloat y;
};

struct _SdxMathPoint2 {
	gint x;
	gint y;
};

struct _SdxMathVector2 {
	gfloat x;
	gfloat y;
};



GType sdx_math_scale_get_type (void) G_GNUC_CONST;
SdxMathScale* sdx_math_scale_dup (const SdxMathScale* self);
void sdx_math_scale_free (SdxMathScale* self);
GType sdx_math_point2_get_type (void) G_GNUC_CONST;
SdxMathPoint2* sdx_math_point2_dup (const SdxMathPoint2* self);
void sdx_math_point2_free (SdxMathPoint2* self);
gfloat sdx_math_Clamp (gfloat value, gfloat low, gfloat hi);
GType sdx_math_vector2_get_type (void) G_GNUC_CONST;
SdxMathVector2* sdx_math_vector2_dup (const SdxMathVector2* self);
void sdx_math_vector2_free (SdxMathVector2* self);
gfloat sdx_math_vector2_Distance (SdxMathVector2* a, SdxMathVector2* b);
void sdx_math_vector2_init (SdxMathVector2 *self, gfloat x, gfloat y);
void sdx_math_vector2_Mul (SdxMathVector2 *self, gfloat f, SdxMathVector2* result);
void sdx_math_vector2_Div (SdxMathVector2 *self, gfloat f, SdxMathVector2* result);
gfloat sdx_math_vector2_Len (SdxMathVector2 *self);
void sdx_math_vector2_Add (SdxMathVector2 *self, SdxMathVector2* v, SdxMathVector2* result);
void sdx_math_vector2_Sub (SdxMathVector2 *self, SdxMathVector2* v, SdxMathVector2* result);
void sdx_math_vector2_get_Zero (SdxMathVector2 * result);
void sdx_math_vector2_get_One (SdxMathVector2 * result);
void sdx_math_vector2_get_Down (SdxMathVector2 * result);
void sdx_math_vector2_get_Left (SdxMathVector2 * result);
void sdx_math_vector2_get_Right (SdxMathVector2 * result);
void sdx_math_vector2_get_Up (SdxMathVector2 * result);


SdxMathScale* sdx_math_scale_dup (const SdxMathScale* self) {
	SdxMathScale* dup;
	dup = g_new0 (SdxMathScale, 1);
	memcpy (dup, self, sizeof (SdxMathScale));
	return dup;
}


void sdx_math_scale_free (SdxMathScale* self) {
	g_free (self);
}


GType sdx_math_scale_get_type (void) {
	static volatile gsize sdx_math_scale_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_math_scale_type_id__volatile)) {
		GType sdx_math_scale_type_id;
		sdx_math_scale_type_id = g_boxed_type_register_static ("SdxMathScale", (GBoxedCopyFunc) sdx_math_scale_dup, (GBoxedFreeFunc) sdx_math_scale_free);
		g_once_init_leave (&sdx_math_scale_type_id__volatile, sdx_math_scale_type_id);
	}
	return sdx_math_scale_type_id__volatile;
}


SdxMathPoint2* sdx_math_point2_dup (const SdxMathPoint2* self) {
	SdxMathPoint2* dup;
	dup = g_new0 (SdxMathPoint2, 1);
	memcpy (dup, self, sizeof (SdxMathPoint2));
	return dup;
}


void sdx_math_point2_free (SdxMathPoint2* self) {
	g_free (self);
}


GType sdx_math_point2_get_type (void) {
	static volatile gsize sdx_math_point2_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_math_point2_type_id__volatile)) {
		GType sdx_math_point2_type_id;
		sdx_math_point2_type_id = g_boxed_type_register_static ("SdxMathPoint2", (GBoxedCopyFunc) sdx_math_point2_dup, (GBoxedFreeFunc) sdx_math_point2_free);
		g_once_init_leave (&sdx_math_point2_type_id__volatile, sdx_math_point2_type_id);
	}
	return sdx_math_point2_type_id__volatile;
}


/**
     * Ensures a value is within a range
     * 
     * @param value to check
     * @param low lower range limit
     * @param hi upper range limit
     * @return value adjusted to range
     */
inline gfloat sdx_math_Clamp (gfloat value, gfloat low, gfloat hi) {
	gfloat result = 0.0F;
	gfloat _tmp0_ = 0.0F;
	gfloat _tmp1_;
	gfloat _tmp2_;
	_tmp1_ = value;
	_tmp2_ = low;
	if (_tmp1_ < _tmp2_) {
		gfloat _tmp3_;
		_tmp3_ = low;
		_tmp0_ = _tmp3_;
	} else {
		gfloat _tmp4_ = 0.0F;
		gfloat _tmp5_;
		gfloat _tmp6_;
		_tmp5_ = value;
		_tmp6_ = hi;
		if (_tmp5_ > _tmp6_) {
			gfloat _tmp7_;
			_tmp7_ = hi;
			_tmp4_ = _tmp7_;
		} else {
			gfloat _tmp8_;
			_tmp8_ = value;
			_tmp4_ = _tmp8_;
		}
		_tmp0_ = _tmp4_;
	}
	result = _tmp0_;
	return result;
}


gfloat sdx_math_vector2_Distance (SdxMathVector2* a, SdxMathVector2* b) {
	gfloat result = 0.0F;
	SdxMathVector2 _tmp0_;
	gfloat _tmp1_;
	SdxMathVector2 _tmp2_;
	gfloat _tmp3_;
	SdxMathVector2 _tmp4_;
	gfloat _tmp5_;
	SdxMathVector2 _tmp6_;
	gfloat _tmp7_;
	SdxMathVector2 _tmp8_;
	gfloat _tmp9_;
	SdxMathVector2 _tmp10_;
	gfloat _tmp11_;
	SdxMathVector2 _tmp12_;
	gfloat _tmp13_;
	SdxMathVector2 _tmp14_;
	gfloat _tmp15_;
	gfloat _tmp16_;
	g_return_val_if_fail (a != NULL, 0.0F);
	g_return_val_if_fail (b != NULL, 0.0F);
	_tmp0_ = *a;
	_tmp1_ = _tmp0_.x;
	_tmp2_ = *b;
	_tmp3_ = _tmp2_.x;
	_tmp4_ = *a;
	_tmp5_ = _tmp4_.x;
	_tmp6_ = *b;
	_tmp7_ = _tmp6_.x;
	_tmp8_ = *a;
	_tmp9_ = _tmp8_.y;
	_tmp10_ = *b;
	_tmp11_ = _tmp10_.y;
	_tmp12_ = *a;
	_tmp13_ = _tmp12_.y;
	_tmp14_ = *b;
	_tmp15_ = _tmp14_.y;
	_tmp16_ = sqrtf (((_tmp1_ - _tmp3_) * (_tmp5_ - _tmp7_)) + ((_tmp9_ - _tmp11_) * (_tmp13_ - _tmp15_)));
	result = _tmp16_;
	return result;
}


void sdx_math_vector2_init (SdxMathVector2 *self, gfloat x, gfloat y) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	memset (self, 0, sizeof (SdxMathVector2));
	_tmp0_ = x;
	(*self).x = _tmp0_;
	_tmp1_ = y;
	(*self).y = _tmp1_;
}


inline void sdx_math_vector2_Mul (SdxMathVector2 *self, gfloat f, SdxMathVector2* result) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	SdxMathVector2 _tmp4_ = {0};
	_tmp0_ = (*self).x;
	_tmp1_ = f;
	_tmp2_ = (*self).y;
	_tmp3_ = f;
	_tmp4_.x = _tmp0_ * _tmp1_;
	_tmp4_.y = _tmp2_ * _tmp3_;
	*result = _tmp4_;
	return;
}


inline void sdx_math_vector2_Div (SdxMathVector2 *self, gfloat f, SdxMathVector2* result) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	SdxMathVector2 _tmp4_ = {0};
	_tmp0_ = (*self).x;
	_tmp1_ = f;
	_tmp2_ = (*self).y;
	_tmp3_ = f;
	_tmp4_.x = _tmp0_ / _tmp1_;
	_tmp4_.y = _tmp2_ / _tmp3_;
	*result = _tmp4_;
	return;
}


inline gfloat sdx_math_vector2_Len (SdxMathVector2 *self) {
	gfloat result = 0.0F;
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	_tmp0_ = (*self).x;
	_tmp1_ = (*self).x;
	_tmp2_ = (*self).y;
	_tmp3_ = (*self).y;
	_tmp4_ = sqrtf ((_tmp0_ * _tmp1_) + (_tmp2_ * _tmp3_));
	result = _tmp4_;
	return result;
}


inline void sdx_math_vector2_Add (SdxMathVector2 *self, SdxMathVector2* v, SdxMathVector2* result) {
	gfloat _tmp0_;
	SdxMathVector2 _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	SdxMathVector2 _tmp4_;
	gfloat _tmp5_;
	SdxMathVector2 _tmp6_ = {0};
	g_return_if_fail (v != NULL);
	_tmp0_ = (*self).x;
	_tmp1_ = *v;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = (*self).y;
	_tmp4_ = *v;
	_tmp5_ = _tmp4_.y;
	_tmp6_.x = _tmp0_ + _tmp2_;
	_tmp6_.y = _tmp3_ + _tmp5_;
	*result = _tmp6_;
	return;
}


inline void sdx_math_vector2_Sub (SdxMathVector2 *self, SdxMathVector2* v, SdxMathVector2* result) {
	gfloat _tmp0_;
	SdxMathVector2 _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	SdxMathVector2 _tmp4_;
	gfloat _tmp5_;
	SdxMathVector2 _tmp6_ = {0};
	g_return_if_fail (v != NULL);
	_tmp0_ = (*self).x;
	_tmp1_ = *v;
	_tmp2_ = _tmp1_.x;
	_tmp3_ = (*self).y;
	_tmp4_ = *v;
	_tmp5_ = _tmp4_.y;
	_tmp6_.x = _tmp0_ - _tmp2_;
	_tmp6_.y = _tmp3_ - _tmp5_;
	*result = _tmp6_;
	return;
}


void sdx_math_vector2_get_Zero (SdxMathVector2 * result) {
	SdxMathVector2 _tmp0_ = {0};
	_tmp0_.x = (gfloat) 0;
	_tmp0_.y = (gfloat) 0;
	*result = _tmp0_;
	return;
}


void sdx_math_vector2_get_One (SdxMathVector2 * result) {
	SdxMathVector2 _tmp0_ = {0};
	_tmp0_.x = (gfloat) 1;
	_tmp0_.y = (gfloat) 1;
	*result = _tmp0_;
	return;
}


void sdx_math_vector2_get_Down (SdxMathVector2 * result) {
	SdxMathVector2 _tmp0_ = {0};
	_tmp0_.x = (gfloat) 0;
	_tmp0_.y = (gfloat) -1;
	*result = _tmp0_;
	return;
}


void sdx_math_vector2_get_Left (SdxMathVector2 * result) {
	SdxMathVector2 _tmp0_ = {0};
	_tmp0_.x = (gfloat) -1;
	_tmp0_.y = (gfloat) 0;
	*result = _tmp0_;
	return;
}


void sdx_math_vector2_get_Right (SdxMathVector2 * result) {
	SdxMathVector2 _tmp0_ = {0};
	_tmp0_.x = (gfloat) 1;
	_tmp0_.y = (gfloat) 0;
	*result = _tmp0_;
	return;
}


void sdx_math_vector2_get_Up (SdxMathVector2 * result) {
	SdxMathVector2 _tmp0_ = {0};
	_tmp0_.x = (gfloat) 0;
	_tmp0_.y = (gfloat) 1;
	*result = _tmp0_;
	return;
}


SdxMathVector2* sdx_math_vector2_dup (const SdxMathVector2* self) {
	SdxMathVector2* dup;
	dup = g_new0 (SdxMathVector2, 1);
	memcpy (dup, self, sizeof (SdxMathVector2));
	return dup;
}


void sdx_math_vector2_free (SdxMathVector2* self) {
	g_free (self);
}


GType sdx_math_vector2_get_type (void) {
	static volatile gsize sdx_math_vector2_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_math_vector2_type_id__volatile)) {
		GType sdx_math_vector2_type_id;
		sdx_math_vector2_type_id = g_boxed_type_register_static ("SdxMathVector2", (GBoxedCopyFunc) sdx_math_vector2_dup, (GBoxedFreeFunc) sdx_math_vector2_free);
		g_once_init_leave (&sdx_math_vector2_type_id__volatile, sdx_math_vector2_type_id);
	}
	return sdx_math_vector2_type_id__volatile;
}





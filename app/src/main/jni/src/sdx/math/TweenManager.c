/** updated by adriac */
/* TweenManager.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from TweenManager.vala, do not modify */

/*[Adriac:Sdx.Math::TweenManager:SdxMathTweenManager:sdx_math_tween_manager]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>

typedef struct _SdxMathTweenManager SdxMathTweenManager;
typedef struct _SdxMathTweenbase SdxMathTweenbase;
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
typedef SdxMathTweenbase SdxMathTween;

#define SDX_MATH_TYPE_TWEEN_KIND (sdx_math_tween_kind_get_type ())
typedef struct _Class Class;
typedef struct _SdxMathTweenAccessor SdxMathTweenAccessor;
typedef struct _SdxMathInterpolation SdxMathInterpolation;

#define SDX_MATH_TYPE_TIMELINE_MODES (sdx_math_timeline_modes_get_type ())
// symtbl.1 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
#define _sdx_math_tweenbase_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tweenbase_release (var), NULL)))
typedef struct _Block25Data Block25Data;
// symtbl.1 sdx_math_tween_manager
void sdx_math_tween_manager_release (SdxMathTweenManager* self);
void sdx_math_tween_manager_free (SdxMathTweenManager* self);
SdxMathTweenManager* sdx_math_tween_manager_retain (SdxMathTweenManager* self);
#define _sdx_math_tween_manager_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tween_manager_release (var), NULL)))

struct _SdxMathTweenManager {
	gint ref_count;
	GPtrArray* objects;
	gboolean isPaused;
};

typedef enum  {
	SDX_MATH_TWEEN_KIND_TWEEN,
	SDX_MATH_TWEEN_KIND_TIMELINE
} SdxMathTweenKind;

typedef void (*SdxMathTweenCallbackOnEvent) (gint type, SdxMathTweenbase* source, void* user_data);
typedef enum  {
	SDX_MATH_TIMELINE_MODES_SEQUENCE,
	SDX_MATH_TIMELINE_MODES_PARALLEL
} SdxMathTimelineModes;

typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenReset) (void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenBuild) (void* user_data);
typedef void (*SdxMathTweenbaseTweenFree) (void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenStart) (SdxMathTweenManager* manager, void* user_data);
typedef void (*SdxMathTweenbaseTweenForceStartValues) (void* user_data);
typedef void (*SdxMathTweenbaseTweenForceEndValues) (void* user_data);
typedef gboolean (*SdxMathTweenbaseTweenContainsTarget) (void* target, gint tweenType, void* user_data);
typedef void (*SdxMathTweenbaseTweenInitializeOverride) (void* user_data);
typedef void (*SdxMathTweenbaseTweenUpdateOverride) (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, void* user_data);
struct _SdxMathTweenbase {
	gint ref_count;
	SdxMathTweenKind kind;
	gint step;
	gint repeatCnt;
	gboolean isIterationStep;
	gboolean isYoyo;
	gfloat delay;
	gfloat duration;
	gfloat repeatDelay;
	gfloat currentTime;
	gfloat deltaTime;
	gboolean isStarted;
	gboolean isInitialized;
	gboolean isFinished;
	gboolean isKilled;
	gboolean isPaused;
	SdxMathTweenCallbackOnEvent callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	gint callbackTriggers;
	void* userData;
	gboolean isAutoRemoveEnabled;
	gboolean isAutoStartEnabled;
	void* target;
	Class* targetClass;
	SdxMathTweenAccessor* accessor;
	gint type;
	SdxMathInterpolation* equation;
	gboolean isFrom;
	gboolean isRelative;
	gint combinedAttrsCnt;
	gint waypointsCnt;
	gfloat* startValues;
	gint startValues_length1;
	gfloat* targetValues;
	gint targetValues_length1;
	gfloat* accessorBuffer;
	gint accessorBuffer_length1;
	GPtrArray* children;
	SdxMathTweenbase* current;
	SdxMathTweenbase* parent;
	SdxMathTimelineModes mode;
	gboolean isBuilt;
	SdxMathTweenbaseTweenReset Reset;
	gpointer Reset_target;
	GDestroyNotify Reset_target_destroy_notify;
	SdxMathTweenbaseTweenBuild Build;
	gpointer Build_target;
	GDestroyNotify Build_target_destroy_notify;
	SdxMathTweenbaseTweenFree Free;
	gpointer Free_target;
	GDestroyNotify Free_target_destroy_notify;
	SdxMathTweenbaseTweenStart Start;
	gpointer Start_target;
	GDestroyNotify Start_target_destroy_notify;
	SdxMathTweenbaseTweenForceStartValues ForceStartValues;
	gpointer ForceStartValues_target;
	GDestroyNotify ForceStartValues_target_destroy_notify;
	SdxMathTweenbaseTweenForceEndValues ForceEndValues;
	gpointer ForceEndValues_target;
	GDestroyNotify ForceEndValues_target_destroy_notify;
	SdxMathTweenbaseTweenContainsTarget ContainsTarget;
	gpointer ContainsTarget_target;
	GDestroyNotify ContainsTarget_target_destroy_notify;
	SdxMathTweenbaseTweenInitializeOverride InitializeOverride;
	gpointer InitializeOverride_target;
	GDestroyNotify InitializeOverride_target_destroy_notify;
	SdxMathTweenbaseTweenUpdateOverride UpdateOverride;
	gpointer UpdateOverride_target;
	GDestroyNotify UpdateOverride_target_destroy_notify;
};

struct _Block25Data {
	int _ref_count_;
	SdxMathTweenManager* self;
	gfloat delta;
};



void sdx_math_tween_manager_free (SdxMathTweenManager * self);
void sdx_math_tweenbase_free (SdxMathTweenbase * self);
static void sdx_math_tween_manager_instance_init (SdxMathTweenManager * self);
SdxMathTweenManager* sdx_math_tween_manager_retain (SdxMathTweenManager* self);
void sdx_math_tween_manager_release (SdxMathTweenManager* self);
void sdx_math_tween_manager_free (SdxMathTweenManager* self);
void sdx_math_tween_manager_SetAutoRemove (SdxMathTween* object, gboolean value);
GType sdx_math_tween_kind_get_type (void) G_GNUC_CONST;
void class_free (Class * self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor * self);
void sdx_math_interpolation_free (SdxMathInterpolation * self);
GType sdx_math_timeline_modes_get_type (void) G_GNUC_CONST;
void sdx_math_tween_manager_SetAutoStart (SdxMathTween* object, gboolean value);
SdxMathTweenManager* sdx_math_tween_manager_new (void);
void sdx_math_interpolation_Initialize (void);
void sdx_math_tween_Init (void);
// symtbl.2 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
static void _sdx_math_tweenbase_release0_ (gpointer var);
SdxMathTweenManager* sdx_math_tween_manager_Add (SdxMathTweenManager* self, SdxMathTweenbase* object);
gboolean sdx_math_tween_manager_ContainsTarget (SdxMathTweenManager* self, void* target, gint tweenType);
void sdx_math_tween_manager_KillAll (SdxMathTweenManager* self);
void sdx_math_tweenbase_Kill (SdxMathTweenbase* self);
void sdx_math_tween_manager_KillTarget (SdxMathTweenManager* self, void* target, gint tweenType);
void sdx_math_tweenbase_KillTarget (SdxMathTweenbase* self, void* target, gint tweenType);
void sdx_math_tween_manager_Pause (SdxMathTweenManager* self);
void sdx_math_tween_manager_Resume (SdxMathTweenManager* self);
void sdx_math_tween_manager_Update (SdxMathTweenManager* self, gfloat delta);
static Block25Data* block25_data_ref (Block25Data* _data25_);
static void block25_data_unref (void * _userdata_);
static void ___lambda90_ (Block25Data* _data25_, SdxMathTweenbase* it);
void sdx_math_tweenbase_Update (SdxMathTweenbase* self, gfloat delta);
static void ____lambda90__gfunc (gconstpointer data, gpointer self);
gint sdx_math_tween_manager_Size (SdxMathTweenManager* self);
gint sdx_math_tween_manager_GetRunningTweensCount (SdxMathTweenManager* self);


SdxMathTweenManager* sdx_math_tween_manager_retain (SdxMathTweenManager* self) {
	SdxMathTweenManager* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_math_tween_manager_release (SdxMathTweenManager* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_math_tween_manager_free (self);
	}
}


/**
         * Disables or enables the "auto remove" mode of any tween manager for a
         * particular tween or timeline. This mode is activated by default. The
         * interest of desactivating it is to prevent some tweens or timelines from
         * being automatically removed from a manager once they are finished.
         * Therefore, if you update a manager backwards, the tweens or timelines
         * will be played again, even if they were finished.
         */
void sdx_math_tween_manager_SetAutoRemove (SdxMathTween* object, gboolean value) {
	SdxMathTween* _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (object != NULL);
	_tmp0_ = object;
	_tmp1_ = value;
	((SdxMathTweenbase*) _tmp0_)->isAutoRemoveEnabled = _tmp1_;
}


/**
         * Disables or enables the "auto start" mode of any tween manager for a
         * particular tween or timeline. This mode is activated by default. If it
         * is not enabled, add a tween or timeline to any manager won't start it
         * automatically, and you'll need to call .start() manually on your object.
         */
void sdx_math_tween_manager_SetAutoStart (SdxMathTween* object, gboolean value) {
	SdxMathTween* _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (object != NULL);
	_tmp0_ = object;
	_tmp1_ = value;
	((SdxMathTweenbase*) _tmp0_)->isAutoStartEnabled = _tmp1_;
}


// symtbl.2 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
static void _sdx_math_tweenbase_release0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (sdx_math_tweenbase_release (var), NULL));
}


SdxMathTweenManager* sdx_math_tween_manager_new (void) {
	SdxMathTweenManager* self;
	GPtrArray* _tmp0_;
	self = g_slice_new0 (SdxMathTweenManager);
	sdx_math_tween_manager_instance_init (self);
	sdx_math_interpolation_Initialize ();
	sdx_math_tween_Init ();
	_tmp0_ = g_ptr_array_new_full ((guint) 20, _sdx_math_tweenbase_release0_);
	_g_ptr_array_unref0 (self->objects);
	self->objects = _tmp0_;
	return self;
}


/**
         * Adds a tween or timeline to the manager and starts or restarts it.
         *
         * @return The manager, for instruction chaining.
         */
static gpointer _sdx_math_tweenbase_retain0 (gpointer self) {
	return self ? sdx_math_tweenbase_retain (self) : NULL;
}


static gpointer _sdx_math_tween_manager_retain0 (gpointer self) {
	return self ? sdx_math_tween_manager_retain (self) : NULL;
}


SdxMathTweenManager* sdx_math_tween_manager_Add (SdxMathTweenManager* self, SdxMathTweenbase* object) {
	SdxMathTweenManager* result = NULL;
	GPtrArray* _tmp0_;
	SdxMathTweenbase* _tmp1_;
	SdxMathTweenbase* _tmp2_;
	SdxMathTweenbase* _tmp3_;
	gboolean _tmp4_;
	SdxMathTweenManager* _tmp9_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (object != NULL, NULL);
	_tmp0_ = self->objects;
	_tmp1_ = object;
	_tmp2_ = _sdx_math_tweenbase_retain0 (_tmp1_);
	g_ptr_array_add (_tmp0_, _tmp2_);
	_tmp3_ = object;
	_tmp4_ = _tmp3_->isAutoStartEnabled;
	if (_tmp4_) {
		SdxMathTweenbase* _tmp5_;
		SdxMathTweenbaseTweenStart _tmp6_;
		void* _tmp6__target;
		SdxMathTweenbase* _tmp7_;
		SdxMathTweenbase* _tmp8_;
		_tmp5_ = object;
		_tmp6_ = _tmp5_->Start;
		_tmp6__target = _tmp5_->Start_target;
		_tmp7_ = _tmp6_ (NULL, _tmp6__target);
		_tmp8_ = _tmp7_;
		_sdx_math_tweenbase_release0 (_tmp8_);
	}
	_tmp9_ = _sdx_math_tween_manager_retain0 (self);
	result = _tmp9_;
	return result;
}


/**
         * Returns true if the manager contains any valid interpolation associated
         * to the given target object and to the given tween type.
         */
static gint g_ptr_array_get_length (GPtrArray* self) {
	gint result;
	guint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->len;
	result = (gint) _tmp0_;
	return result;
}


static void g_ptr_array_set_length (GPtrArray* self, gint value) {
	gint _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = value;
	g_ptr_array_set_size (self, _tmp0_);
}


gboolean sdx_math_tween_manager_ContainsTarget (SdxMathTweenManager* self, void* target, gint tweenType) {
	gboolean result = FALSE;
	g_return_val_if_fail (self != NULL, FALSE);
	{
		gint i = 0;
		gint n = 0;
		GPtrArray* _tmp0_;
		gint _tmp1_;
		gint _tmp2_;
		i = 0;
		_tmp0_ = self->objects;
		_tmp1_ = g_ptr_array_get_length (_tmp0_);
		_tmp2_ = _tmp1_;
		n = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gint _tmp6_;
				SdxMathTweenbase* obj = NULL;
				GPtrArray* _tmp7_;
				gint _tmp8_;
				gconstpointer _tmp9_;
				SdxMathTweenbase* _tmp10_;
				SdxMathTweenbase* _tmp11_;
				SdxMathTweenbaseTweenContainsTarget _tmp12_;
				void* _tmp12__target;
				void* _tmp13_;
				gint _tmp14_;
				gboolean _tmp15_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = n;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = self->objects;
				_tmp8_ = i;
				_tmp9_ = g_ptr_array_index (_tmp7_, (guint) _tmp8_);
				_tmp10_ = _sdx_math_tweenbase_retain0 ((SdxMathTweenbase*) _tmp9_);
				obj = _tmp10_;
				_tmp11_ = obj;
				_tmp12_ = _tmp11_->ContainsTarget;
				_tmp12__target = _tmp11_->ContainsTarget_target;
				_tmp13_ = target;
				_tmp14_ = tweenType;
				_tmp15_ = _tmp12_ (_tmp13_, _tmp14_, _tmp12__target);
				if (_tmp15_) {
					result = TRUE;
					_sdx_math_tweenbase_release0 (obj);
					return result;
				}
				_sdx_math_tweenbase_release0 (obj);
			}
		}
	}
	result = FALSE;
	return result;
}


/**
         * Kills every managed tweens and timelines.
         */
void sdx_math_tween_manager_KillAll (SdxMathTweenManager* self) {
	g_return_if_fail (self != NULL);
	{
		gint i = 0;
		gint n = 0;
		GPtrArray* _tmp0_;
		gint _tmp1_;
		gint _tmp2_;
		i = 0;
		_tmp0_ = self->objects;
		_tmp1_ = g_ptr_array_get_length (_tmp0_);
		_tmp2_ = _tmp1_;
		n = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gint _tmp6_;
				SdxMathTweenbase* obj = NULL;
				GPtrArray* _tmp7_;
				gint _tmp8_;
				gconstpointer _tmp9_;
				SdxMathTweenbase* _tmp10_;
				SdxMathTweenbase* _tmp11_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = n;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = self->objects;
				_tmp8_ = i;
				_tmp9_ = g_ptr_array_index (_tmp7_, (guint) _tmp8_);
				_tmp10_ = _sdx_math_tweenbase_retain0 ((SdxMathTweenbase*) _tmp9_);
				obj = _tmp10_;
				_tmp11_ = obj;
				sdx_math_tweenbase_Kill (_tmp11_);
				_sdx_math_tweenbase_release0 (obj);
			}
		}
	}
}


/**
         * Kills every tweens associated to the given target and tween type. Will
         * also kill every timelines containing a tween associated to the given
         * target and tween type.
         */
void sdx_math_tween_manager_KillTarget (SdxMathTweenManager* self, void* target, gint tweenType) {
	g_return_if_fail (self != NULL);
	{
		gint i = 0;
		gint n = 0;
		GPtrArray* _tmp0_;
		gint _tmp1_;
		gint _tmp2_;
		i = 0;
		_tmp0_ = self->objects;
		_tmp1_ = g_ptr_array_get_length (_tmp0_);
		_tmp2_ = _tmp1_;
		n = _tmp2_;
		{
			gboolean _tmp3_ = FALSE;
			_tmp3_ = TRUE;
			while (TRUE) {
				gint _tmp5_;
				gint _tmp6_;
				SdxMathTweenbase* obj = NULL;
				GPtrArray* _tmp7_;
				gint _tmp8_;
				gconstpointer _tmp9_;
				SdxMathTweenbase* _tmp10_;
				SdxMathTweenbase* _tmp11_;
				void* _tmp12_;
				gint _tmp13_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp3_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = n;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = self->objects;
				_tmp8_ = i;
				_tmp9_ = g_ptr_array_index (_tmp7_, (guint) _tmp8_);
				_tmp10_ = _sdx_math_tweenbase_retain0 ((SdxMathTweenbase*) _tmp9_);
				obj = _tmp10_;
				_tmp11_ = obj;
				_tmp12_ = target;
				_tmp13_ = tweenType;
				sdx_math_tweenbase_KillTarget (_tmp11_, _tmp12_, _tmp13_);
				_sdx_math_tweenbase_release0 (obj);
			}
		}
	}
}


/**
         * Pauses the manager. Further update calls won't have any effect.
         */
void sdx_math_tween_manager_Pause (SdxMathTweenManager* self) {
	g_return_if_fail (self != NULL);
	self->isPaused = TRUE;
}


/**
         * Resumes the manager, if paused.
         */
void sdx_math_tween_manager_Resume (SdxMathTweenManager* self) {
	g_return_if_fail (self != NULL);
	self->isPaused = FALSE;
}


/**
         * Updates every tweens with a delta time ang handles the tween life-cycles
         * automatically. If a tween is finished, it will be removed from the
         * manager. The delta time represents the elapsed time between now and the
         * last update call. Each tween or timeline manages its local time, and adds
         * this delta to its local time to update itself.
         *
         * Slow motion, fast motion and backward play can be easily achieved by
         * tweaking this delta time. Multiply it by -1 to play the animation
         * backward, or by 0.5 to play it twice slower than its normal speed.
         */
static Block25Data* block25_data_ref (Block25Data* _data25_) {
	g_atomic_int_inc (&_data25_->_ref_count_);
	return _data25_;
}


static void block25_data_unref (void * _userdata_) {
	Block25Data* _data25_;
	_data25_ = (Block25Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data25_->_ref_count_)) {
		SdxMathTweenManager* self;
		self = _data25_->self;
		_sdx_math_tween_manager_release0 (self);
		g_slice_free (Block25Data, _data25_);
	}
}


static void ___lambda90_ (Block25Data* _data25_, SdxMathTweenbase* it) {
	SdxMathTweenManager* self;
	SdxMathTweenbase* _tmp0_;
	gfloat _tmp1_;
	self = _data25_->self;
	g_return_if_fail (it != NULL);
	_tmp0_ = it;
	_tmp1_ = _data25_->delta;
	sdx_math_tweenbase_Update (_tmp0_, _tmp1_);
}


static void ____lambda90__gfunc (gconstpointer data, gpointer self) {
	___lambda90_ (self, (SdxMathTweenbase*) data);
}


void sdx_math_tween_manager_Update (SdxMathTweenManager* self, gfloat delta) {
	Block25Data* _data25_;
	gfloat _tmp0_;
	GPtrArray* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	_data25_ = g_slice_new0 (Block25Data);
	_data25_->_ref_count_ = 1;
	_data25_->self = sdx_math_tween_manager_retain (self);
	_tmp0_ = delta;
	_data25_->delta = _tmp0_;
	_tmp1_ = self->objects;
	_tmp2_ = g_ptr_array_get_length (_tmp1_);
	_tmp3_ = _tmp2_;
	if (_tmp3_ == 0) {
		block25_data_unref (_data25_);
		_data25_ = NULL;
		return;
	}
	_tmp4_ = self->isPaused;
	if (!_tmp4_) {
		GPtrArray* _tmp5_;
		_tmp5_ = self->objects;
		g_ptr_array_foreach (_tmp5_, ____lambda90__gfunc, _data25_);
	}
	block25_data_unref (_data25_);
	_data25_ = NULL;
}


/**
         * Gets the number of managed objects. An object may be a tween or a
         * timeline. Note that a timeline only counts for 1 object, since it
         * manages its children itself.
         * 
         * To get the count of running tweens, see {@link GetRunningTweensCount}.
         */
gint sdx_math_tween_manager_Size (SdxMathTweenManager* self) {
	gint result = 0;
	GPtrArray* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->objects;
	_tmp1_ = g_ptr_array_get_length (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


/**
         * Gets the number of running tweens. This number includes the tweens
         * located inside timelines (and nested timelin
         * 
         * ''Provided for debug purpose only.''
         */
gint sdx_math_tween_manager_GetRunningTweensCount (SdxMathTweenManager* self) {
	gint result = 0;
	GPtrArray* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->objects;
	_tmp1_ = g_ptr_array_get_length (_tmp0_);
	_tmp2_ = _tmp1_;
	result = _tmp2_;
	return result;
}


static void sdx_math_tween_manager_instance_init (SdxMathTweenManager * self) {
	self->ref_count = 1;
	self->isPaused = FALSE;
}


void sdx_math_tween_manager_free (SdxMathTweenManager * self) {
	_g_ptr_array_unref0 (self->objects);
	g_slice_free (SdxMathTweenManager, self);
}





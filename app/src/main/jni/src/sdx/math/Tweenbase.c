/** updated by adriac */
/* Tweenbase.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Tweenbase.vala, do not modify */

/*[Adriac:Sdx.Math::Tweenbase:SdxMathTweenbase:sdx_math_tweenbase]*/
/*[Adriac:Sdx.Math::of:SdxMathof:sdx_math_of]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>


#define SDX_MATH_TYPE_TIMELINE_MODES (sdx_math_timeline_modes_get_type ())

#define SDX_MATH_TYPE_TWEEN_KIND (sdx_math_tween_kind_get_type ())
typedef struct _SdxMathTweenbase SdxMathTweenbase;
typedef struct _Class Class;
typedef struct _SdxMathTweenAccessor SdxMathTweenAccessor;
typedef struct _SdxMathInterpolation SdxMathInterpolation;
typedef struct _SdxMathTweenManager SdxMathTweenManager;

#define SDX_MATH_TWEENBASE_TYPE_TWEEN_CALLBACK (sdx_math_tweenbase_tween_callback_get_type ())
// symtbl.1 sdx_math_tween_accessor
void sdx_math_tween_accessor_release (SdxMathTweenAccessor* self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor* self);
SdxMathTweenAccessor* sdx_math_tween_accessor_retain (SdxMathTweenAccessor* self);
#define _sdx_math_tween_accessor_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tween_accessor_release (var), NULL)))
// symtbl.1 sdx_math_interpolation
void sdx_math_interpolation_release (SdxMathInterpolation* self);
void sdx_math_interpolation_free (SdxMathInterpolation* self);
SdxMathInterpolation* sdx_math_interpolation_retain (SdxMathInterpolation* self);
#define _sdx_math_interpolation_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_interpolation_release (var), NULL)))
#define _g_ptr_array_unref0(var) ((var == NULL) ? NULL : (var = (g_ptr_array_unref (var), NULL)))
// symtbl.1 sdx_math_tweenbase
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
#define _sdx_math_tweenbase_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tweenbase_release (var), NULL)))
// symtbl.1 sdx_math_tween_manager
void sdx_math_tween_manager_release (SdxMathTweenManager* self);
void sdx_math_tween_manager_free (SdxMathTweenManager* self);
SdxMathTweenManager* sdx_math_tween_manager_retain (SdxMathTweenManager* self);
#define _sdx_math_tween_manager_release0(var) ((var == NULL) ? NULL : (var = (sdx_math_tween_manager_release (var), NULL)))
#define _vala_assert(expr, msg) if G_LIKELY (expr) ; else g_assertion_message_expr (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);
#define _vala_return_if_fail(expr, msg) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return; }
#define _vala_return_val_if_fail(expr, msg, val) if G_LIKELY (expr) ; else { g_return_if_fail_warning (G_LOG_DOMAIN, G_STRFUNC, msg); return val; }
#define _vala_warn_if_fail(expr, msg) if G_LIKELY (expr) ; else g_warn_message (G_LOG_DOMAIN, __FILE__, __LINE__, G_STRFUNC, msg);

typedef enum  {
	SDX_MATH_TIMELINE_MODES_SEQUENCE,
	SDX_MATH_TIMELINE_MODES_PARALLEL
} SdxMathTimelineModes;

typedef enum  {
	SDX_MATH_TWEEN_KIND_TWEEN,
	SDX_MATH_TWEEN_KIND_TIMELINE
} SdxMathTweenKind;

typedef void (*SdxMathTweenCallbackOnEvent) (gint type, SdxMathTweenbase* source, void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenReset) (void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenBuild) (void* user_data);
typedef void (*SdxMathTweenbaseTweenFree) (void* user_data);
typedef SdxMathTweenbase* (*SdxMathTweenbaseTweenStart) (SdxMathTweenManager* manager, void* user_data);
typedef void (*SdxMathTweenbaseTweenForceStartValues) (void* user_data);
typedef void (*SdxMathTweenbaseTweenForceEndValues) (void* user_data);
typedef gboolean (*SdxMathTweenbaseTweenContainsTarget) (void* target, gint tweenType, void* user_data);
typedef void (*SdxMathTweenbaseTweenInitializeOverride) (void* user_data);
typedef void (*SdxMathTweenbaseTweenUpdateOverride) (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, void* user_data);
struct _SdxMathTweenbase {
	gint ref_count;
	SdxMathTweenKind kind;
	gint step;
	gint repeatCnt;
	gboolean isIterationStep;
	gboolean isYoyo;
	gfloat delay;
	gfloat duration;
	gfloat repeatDelay;
	gfloat currentTime;
	gfloat deltaTime;
	gboolean isStarted;
	gboolean isInitialized;
	gboolean isFinished;
	gboolean isKilled;
	gboolean isPaused;
	SdxMathTweenCallbackOnEvent callback;
	gpointer callback_target;
	GDestroyNotify callback_target_destroy_notify;
	gint callbackTriggers;
	void* userData;
	gboolean isAutoRemoveEnabled;
	gboolean isAutoStartEnabled;
	void* target;
	Class* targetClass;
	SdxMathTweenAccessor* accessor;
	gint type;
	SdxMathInterpolation* equation;
	gboolean isFrom;
	gboolean isRelative;
	gint combinedAttrsCnt;
	gint waypointsCnt;
	gfloat* startValues;
	gint startValues_length1;
	gfloat* targetValues;
	gint targetValues_length1;
	gfloat* accessorBuffer;
	gint accessorBuffer_length1;
	GPtrArray* children;
	SdxMathTweenbase* current;
	SdxMathTweenbase* parent;
	SdxMathTimelineModes mode;
	gboolean isBuilt;
	SdxMathTweenbaseTweenReset Reset;
	gpointer Reset_target;
	GDestroyNotify Reset_target_destroy_notify;
	SdxMathTweenbaseTweenBuild Build;
	gpointer Build_target;
	GDestroyNotify Build_target_destroy_notify;
	SdxMathTweenbaseTweenFree Free;
	gpointer Free_target;
	GDestroyNotify Free_target_destroy_notify;
	SdxMathTweenbaseTweenStart Start;
	gpointer Start_target;
	GDestroyNotify Start_target_destroy_notify;
	SdxMathTweenbaseTweenForceStartValues ForceStartValues;
	gpointer ForceStartValues_target;
	GDestroyNotify ForceStartValues_target_destroy_notify;
	SdxMathTweenbaseTweenForceEndValues ForceEndValues;
	gpointer ForceEndValues_target;
	GDestroyNotify ForceEndValues_target_destroy_notify;
	SdxMathTweenbaseTweenContainsTarget ContainsTarget;
	gpointer ContainsTarget_target;
	GDestroyNotify ContainsTarget_target_destroy_notify;
	SdxMathTweenbaseTweenInitializeOverride InitializeOverride;
	gpointer InitializeOverride_target;
	GDestroyNotify InitializeOverride_target_destroy_notify;
	SdxMathTweenbaseTweenUpdateOverride UpdateOverride;
	gpointer UpdateOverride_target;
	GDestroyNotify UpdateOverride_target_destroy_notify;
};

typedef enum  {
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BEGIN = 0x01,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START = 0x02,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_END = 0x04,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_COMPLETE = 0x08,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_BEGIN = 0x10,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_START = 0x20,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_END = 0x40,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_COMPLETE = 0x80,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_FORWARD = 0x0F,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_BACKWARD = 0xF0,
	SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY = 0xFF
} SdxMathTweenbaseTweenCallback;

typedef enum  {
	SDX_EXCEPTION_IllegalArgumentException,
	SDX_EXCEPTION_RuntimeException
} SdxException;
#define SDX_EXCEPTION sdx_exception_quark ()

extern gint sdx_math_tweenbase_combinedAttrsLimit;
gint sdx_math_tweenbase_combinedAttrsLimit = 3;
extern gint sdx_math_tweenbase_waypointsLimit;
gint sdx_math_tweenbase_waypointsLimit = 0;
extern GPtrArray* sdx_math_tweenbase_pool;
GPtrArray* sdx_math_tweenbase_pool = NULL;
extern GHashTable* sdx_math_tweenbase_registeredAccessors;
GHashTable* sdx_math_tweenbase_registeredAccessors = NULL;

GType sdx_math_timeline_modes_get_type (void) G_GNUC_CONST;
GType sdx_math_tween_kind_get_type (void) G_GNUC_CONST;
void sdx_math_tweenbase_free (SdxMathTweenbase * self);
void class_free (Class * self);
void sdx_math_tween_accessor_free (SdxMathTweenAccessor * self);
void sdx_math_interpolation_free (SdxMathInterpolation * self);
void sdx_math_tween_manager_free (SdxMathTweenManager * self);
static void sdx_math_tweenbase_instance_init (SdxMathTweenbase * self);
GType sdx_math_tweenbase_tween_callback_get_type (void) G_GNUC_CONST;
static SdxMathTweenbase* _sdx_math_tweenbase_reset_lambda75_ (void);
static SdxMathTweenbase* __sdx_math_tweenbase_reset_lambda75__sdx_math_tweenbase_tween_reset (gpointer self);
static SdxMathTweenbase* _sdx_math_tweenbase_build_lambda76_ (void);
static SdxMathTweenbase* __sdx_math_tweenbase_build_lambda76__sdx_math_tweenbase_tween_build (gpointer self);
static void _sdx_math_tweenbase_free_lambda77_ (void);
static void __sdx_math_tweenbase_free_lambda77__sdx_math_tweenbase_tween_free (gpointer self);
static SdxMathTweenbase* _sdx_math_tweenbase_start_lambda91_ (SdxMathTweenManager* manager);
static SdxMathTweenbase* __sdx_math_tweenbase_start_lambda91__sdx_math_tweenbase_tween_start (SdxMathTweenManager* manager, gpointer self);
static void _sdx_math_tweenbase_force_start_values_lambda84_ (void);
static void __sdx_math_tweenbase_force_start_values_lambda84__sdx_math_tweenbase_tween_force_start_values (gpointer self);
static void _sdx_math_tweenbase_force_end_values_lambda86_ (void);
static void __sdx_math_tweenbase_force_end_values_lambda86__sdx_math_tweenbase_tween_force_end_values (gpointer self);
static gboolean _sdx_math_tweenbase_contains_target_lambda88_ (void* target, gint tweenType);
static gboolean __sdx_math_tweenbase_contains_target_lambda88__sdx_math_tweenbase_tween_contains_target (void* target, gint tweenType, gpointer self);
static void _sdx_math_tweenbase_initialize_override_lambda80_ (void);
static void __sdx_math_tweenbase_initialize_override_lambda80__sdx_math_tweenbase_tween_initialize_override (gpointer self);
static void _sdx_math_tweenbase_update_override_lambda82_ (gint step, gint lastStep, gboolean isIterationStep, gfloat delta);
static void __sdx_math_tweenbase_update_override_lambda82__sdx_math_tweenbase_tween_update_override (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, gpointer self);
SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self);
void sdx_math_tweenbase_release (SdxMathTweenbase* self);
void sdx_math_tweenbase_free (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_new (void);
static SdxMathTweenbase* __lambda92_ (SdxMathTweenbase* self);
static SdxMathTweenbase* ___lambda92__sdx_math_tweenbase_tween_reset (gpointer self);
static SdxMathTweenbase* __lambda93_ (SdxMathTweenbase* self, SdxMathTweenManager* manager);
SdxMathTweenManager* sdx_math_tween_manager_Add (SdxMathTweenManager* self, SdxMathTweenbase* object);
static SdxMathTweenbase* ___lambda93__sdx_math_tweenbase_tween_start (SdxMathTweenManager* manager, gpointer self);
SdxMathTweenbase* sdx_math_tweenbase_Delay (SdxMathTweenbase* self, gfloat delay);
void sdx_math_tweenbase_Kill (SdxMathTweenbase* self);
void sdx_math_tweenbase_Pause (SdxMathTweenbase* self);
void sdx_math_tweenbase_Resume (SdxMathTweenbase* self);
SdxMathTweenbase* sdx_math_tweenbase_Repeat (SdxMathTweenbase* self, gint count, gfloat delay);
GQuark sdx_exception_quark (void);
SdxMathTweenbase* sdx_math_tweenbase_RepeatYoyo (SdxMathTweenbase* self, gint count, gfloat delay);
SdxMathTweenbase* sdx_math_tweenbase_SetCallback (SdxMathTweenbase* self, SdxMathTweenCallbackOnEvent callback, void* callback_target);
SdxMathTweenbase* sdx_math_tweenbase_SetCallbackTriggers (SdxMathTweenbase* self, gint flags);
SdxMathTweenbase* sdx_math_tweenbase_SetUserData (SdxMathTweenbase* self, void* data);
gfloat sdx_math_tweenbase_GetDelay (SdxMathTweenbase* self);
gfloat sdx_math_tweenbase_GetDuration (SdxMathTweenbase* self);
gint sdx_math_tweenbase_GetRepeatCount (SdxMathTweenbase* self);
gfloat sdx_math_tweenbase_GetRepeatDelay (SdxMathTweenbase* self);
gfloat sdx_math_tweenbase_GetFullDuration (SdxMathTweenbase* self);
void* sdx_math_tweenbase_GetUserData (SdxMathTweenbase* self);
gint sdx_math_tweenbase_GetStep (SdxMathTweenbase* self);
gfloat sdx_math_tweenbase_GetCurrentTime (SdxMathTweenbase* self);
gboolean sdx_math_tweenbase_IsStarted (SdxMathTweenbase* self);
gboolean sdx_math_tweenbase_IsInitialized (SdxMathTweenbase* self);
gboolean sdx_math_tweenbase_IsFinished (SdxMathTweenbase* self);
gboolean sdx_math_tweenbase_IsYoyo (SdxMathTweenbase* self);
gboolean sdx_math_tweenbase_IsPaused (SdxMathTweenbase* self);
void sdx_math_tweenbase_ForceToStart (SdxMathTweenbase* self);
gboolean sdx_math_tweenbase_IsReverse (SdxMathTweenbase* self, gint step);
void sdx_math_tweenbase_ForceToEnd (SdxMathTweenbase* self, gfloat time);
void sdx_math_tweenbase_CallCallback (SdxMathTweenbase* self, gint type);
gboolean sdx_math_tweenbase_IsValid (SdxMathTweenbase* self, gint step);
void sdx_math_tweenbase_KillTarget (SdxMathTweenbase* self, void* target, gint tweenType);
void sdx_math_tweenbase_Update (SdxMathTweenbase* self, gfloat delta);
void sdx_math_tweenbase_Initialize (SdxMathTweenbase* self);
void sdx_math_tweenbase_TestRelaunch (SdxMathTweenbase* self);
void sdx_math_tweenbase_UpdateStep (SdxMathTweenbase* self);
void sdx_math_tweenbase_TestCompletion (SdxMathTweenbase* self);


GType sdx_math_timeline_modes_get_type (void) {
	static volatile gsize sdx_math_timeline_modes_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_math_timeline_modes_type_id__volatile)) {
		static const GEnumValue values[] = {{SDX_MATH_TIMELINE_MODES_SEQUENCE, "SDX_MATH_TIMELINE_MODES_SEQUENCE", "sequence"}, {SDX_MATH_TIMELINE_MODES_PARALLEL, "SDX_MATH_TIMELINE_MODES_PARALLEL", "parallel"}, {0, NULL, NULL}};
		GType sdx_math_timeline_modes_type_id;
		sdx_math_timeline_modes_type_id = g_enum_register_static ("SdxMathTimelineModes", values);
		g_once_init_leave (&sdx_math_timeline_modes_type_id__volatile, sdx_math_timeline_modes_type_id);
	}
	return sdx_math_timeline_modes_type_id__volatile;
}


GType sdx_math_tween_kind_get_type (void) {
	static volatile gsize sdx_math_tween_kind_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_math_tween_kind_type_id__volatile)) {
		static const GEnumValue values[] = {{SDX_MATH_TWEEN_KIND_TWEEN, "SDX_MATH_TWEEN_KIND_TWEEN", "tween"}, {SDX_MATH_TWEEN_KIND_TIMELINE, "SDX_MATH_TWEEN_KIND_TIMELINE", "timeline"}, {0, NULL, NULL}};
		GType sdx_math_tween_kind_type_id;
		sdx_math_tween_kind_type_id = g_enum_register_static ("SdxMathTweenKind", values);
		g_once_init_leave (&sdx_math_tween_kind_type_id__volatile, sdx_math_tween_kind_type_id);
	}
	return sdx_math_tween_kind_type_id__volatile;
}


GType sdx_math_tweenbase_tween_callback_get_type (void) {
	static volatile gsize sdx_math_tweenbase_tween_callback_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_math_tweenbase_tween_callback_type_id__volatile)) {
		static const GEnumValue values[] = {{SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BEGIN, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BEGIN", "begin"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START", "start"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_END, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_END", "end"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_COMPLETE, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_COMPLETE", "complete"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_BEGIN, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_BEGIN", "back-begin"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_START, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_START", "back-start"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_END, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_END", "back-end"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_COMPLETE, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_COMPLETE", "back-complete"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_FORWARD, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_FORWARD", "any-forward"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_BACKWARD, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY_BACKWARD", "any-backward"}, {SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY, "SDX_MATH_TWEENBASE_TWEEN_CALLBACK_ANY", "any"}, {0, NULL, NULL}};
		GType sdx_math_tweenbase_tween_callback_type_id;
		sdx_math_tweenbase_tween_callback_type_id = g_enum_register_static ("SdxMathTweenbaseTweenCallback", values);
		g_once_init_leave (&sdx_math_tweenbase_tween_callback_type_id__volatile, sdx_math_tweenbase_tween_callback_type_id);
	}
	return sdx_math_tweenbase_tween_callback_type_id__volatile;
}


static SdxMathTweenbase* _sdx_math_tweenbase_reset_lambda75_ (void) {
	SdxMathTweenbase* result = NULL;
}


static SdxMathTweenbase* __sdx_math_tweenbase_reset_lambda75__sdx_math_tweenbase_tween_reset (gpointer self) {
	SdxMathTweenbase* result;
	result = _sdx_math_tweenbase_reset_lambda75_ ();
	return result;
}


static SdxMathTweenbase* _sdx_math_tweenbase_build_lambda76_ (void) {
	SdxMathTweenbase* result = NULL;
}


static SdxMathTweenbase* __sdx_math_tweenbase_build_lambda76__sdx_math_tweenbase_tween_build (gpointer self) {
	SdxMathTweenbase* result;
	result = _sdx_math_tweenbase_build_lambda76_ ();
	return result;
}


static void _sdx_math_tweenbase_free_lambda77_ (void) {
}


static void __sdx_math_tweenbase_free_lambda77__sdx_math_tweenbase_tween_free (gpointer self) {
	_sdx_math_tweenbase_free_lambda77_ ();
}


static SdxMathTweenbase* _sdx_math_tweenbase_start_lambda91_ (SdxMathTweenManager* manager) {
	SdxMathTweenbase* result = NULL;
}


static SdxMathTweenbase* __sdx_math_tweenbase_start_lambda91__sdx_math_tweenbase_tween_start (SdxMathTweenManager* manager, gpointer self) {
	SdxMathTweenbase* result;
	result = _sdx_math_tweenbase_start_lambda91_ (manager);
	return result;
}


static void _sdx_math_tweenbase_force_start_values_lambda84_ (void) {
}


static void __sdx_math_tweenbase_force_start_values_lambda84__sdx_math_tweenbase_tween_force_start_values (gpointer self) {
	_sdx_math_tweenbase_force_start_values_lambda84_ ();
}


static void _sdx_math_tweenbase_force_end_values_lambda86_ (void) {
}


static void __sdx_math_tweenbase_force_end_values_lambda86__sdx_math_tweenbase_tween_force_end_values (gpointer self) {
	_sdx_math_tweenbase_force_end_values_lambda86_ ();
}


static gboolean _sdx_math_tweenbase_contains_target_lambda88_ (void* target, gint tweenType) {
	gboolean result = FALSE;
}


static gboolean __sdx_math_tweenbase_contains_target_lambda88__sdx_math_tweenbase_tween_contains_target (void* target, gint tweenType, gpointer self) {
	gboolean result;
	result = _sdx_math_tweenbase_contains_target_lambda88_ (target, tweenType);
	return result;
}


static void _sdx_math_tweenbase_initialize_override_lambda80_ (void) {
}


static void __sdx_math_tweenbase_initialize_override_lambda80__sdx_math_tweenbase_tween_initialize_override (gpointer self) {
	_sdx_math_tweenbase_initialize_override_lambda80_ ();
}


static void _sdx_math_tweenbase_update_override_lambda82_ (gint step, gint lastStep, gboolean isIterationStep, gfloat delta) {
}


static void __sdx_math_tweenbase_update_override_lambda82__sdx_math_tweenbase_tween_update_override (gint step, gint lastStep, gboolean isIterationStep, gfloat delta, gpointer self) {
	_sdx_math_tweenbase_update_override_lambda82_ (step, lastStep, isIterationStep, delta);
}


SdxMathTweenbase* sdx_math_tweenbase_retain (SdxMathTweenbase* self) {
	SdxMathTweenbase* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_math_tweenbase_release (SdxMathTweenbase* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_math_tweenbase_free (self);
	}
}


static gpointer _sdx_math_tweenbase_retain0 (gpointer self) {
	return self ? sdx_math_tweenbase_retain (self) : NULL;
}


static SdxMathTweenbase* __lambda92_ (SdxMathTweenbase* self) {
	SdxMathTweenbase* result = NULL;
	gboolean _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gboolean _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	gboolean _tmp8_;
	gboolean _tmp9_;
	SdxMathTweenbase* _tmp10_;
	self->step = -2;
	self->repeatCnt = 0;
	self->isYoyo = FALSE;
	_tmp0_ = self->isYoyo;
	self->isIterationStep = _tmp0_;
	self->deltaTime = (gfloat) 0;
	_tmp1_ = self->deltaTime;
	self->currentTime = _tmp1_;
	_tmp2_ = self->currentTime;
	self->repeatDelay = _tmp2_;
	_tmp3_ = self->repeatDelay;
	self->duration = _tmp3_;
	_tmp4_ = self->duration;
	self->delay = _tmp4_;
	self->isPaused = FALSE;
	_tmp5_ = self->isPaused;
	self->isKilled = _tmp5_;
	_tmp6_ = self->isKilled;
	self->isFinished = _tmp6_;
	_tmp7_ = self->isFinished;
	self->isInitialized = _tmp7_;
	_tmp8_ = self->isInitialized;
	self->isStarted = _tmp8_;
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	self->callbackTriggers = (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_COMPLETE;
	self->userData = NULL;
	self->isAutoStartEnabled = TRUE;
	_tmp9_ = self->isAutoStartEnabled;
	self->isAutoRemoveEnabled = _tmp9_;
	_tmp10_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp10_;
	return result;
}


static SdxMathTweenbase* ___lambda92__sdx_math_tweenbase_tween_reset (gpointer self) {
	SdxMathTweenbase* result;
	result = __lambda92_ ((SdxMathTweenbase*) self);
	return result;
}


static SdxMathTweenbase* __lambda93_ (SdxMathTweenbase* self, SdxMathTweenManager* manager) {
	SdxMathTweenbase* result = NULL;
	SdxMathTweenManager* _tmp0_;
	SdxMathTweenbase* _tmp7_;
	_tmp0_ = manager;
	if (_tmp0_ == NULL) {
		SdxMathTweenbaseTweenBuild _tmp1_;
		void* _tmp1__target;
		SdxMathTweenbase* _tmp2_;
		SdxMathTweenbase* _tmp3_;
		_tmp1_ = self->Build;
		_tmp1__target = self->Build_target;
		_tmp2_ = _tmp1_ (_tmp1__target);
		_tmp3_ = _tmp2_;
		_sdx_math_tweenbase_release0 (_tmp3_);
		self->currentTime = (gfloat) 0;
		self->isStarted = TRUE;
	} else {
		SdxMathTweenManager* _tmp4_;
		SdxMathTweenManager* _tmp5_;
		SdxMathTweenManager* _tmp6_;
		_tmp4_ = manager;
		_tmp5_ = sdx_math_tween_manager_Add (_tmp4_, self);
		_tmp6_ = _tmp5_;
		_sdx_math_tween_manager_release0 (_tmp6_);
	}
	_tmp7_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp7_;
	return result;
}


static SdxMathTweenbase* ___lambda93__sdx_math_tweenbase_tween_start (SdxMathTweenManager* manager, gpointer self) {
	SdxMathTweenbase* result;
	result = __lambda93_ ((SdxMathTweenbase*) self, manager);
	return result;
}


SdxMathTweenbase* sdx_math_tweenbase_new (void) {
	SdxMathTweenbase* self;
	self = g_slice_new0 (SdxMathTweenbase);
	sdx_math_tweenbase_instance_init (self);
	(self->Reset_target_destroy_notify == NULL) ? NULL : (self->Reset_target_destroy_notify (self->Reset_target), NULL);
	self->Reset = NULL;
	self->Reset_target = NULL;
	self->Reset_target_destroy_notify = NULL;
	self->Reset = ___lambda92__sdx_math_tweenbase_tween_reset;
	self->Reset_target = sdx_math_tweenbase_retain (self);
	self->Reset_target_destroy_notify = sdx_math_tweenbase_release;
	(self->Start_target_destroy_notify == NULL) ? NULL : (self->Start_target_destroy_notify (self->Start_target), NULL);
	self->Start = NULL;
	self->Start_target = NULL;
	self->Start_target_destroy_notify = NULL;
	self->Start = ___lambda93__sdx_math_tweenbase_tween_start;
	self->Start_target = sdx_math_tweenbase_retain (self);
	self->Start_target_destroy_notify = sdx_math_tweenbase_release;
	return self;
}


/**
         * Adds a delay to the tween or timeline.
         *
         * @param delay A duration.
         * @return The current object, for chaining instructions.
         */
SdxMathTweenbase* sdx_math_tweenbase_Delay (SdxMathTweenbase* self, gfloat delay) {
	SdxMathTweenbase* result = NULL;
	gfloat _tmp0_;
	gfloat _tmp1_;
	SdxMathTweenbase* _tmp2_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->delay;
	_tmp1_ = delay;
	self->delay = _tmp0_ + _tmp1_;
	_tmp2_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp2_;
	return result;
}


/**
         * Kills the tween or timeline. If you are using a TweenManager, this object
         * will be removed automatically.
         */
void sdx_math_tweenbase_Kill (SdxMathTweenbase* self) {
	g_return_if_fail (self != NULL);
	self->isKilled = TRUE;
}


/**
         * Pauses the tween or timeline. Further update calls won't have any effect.
         */
void sdx_math_tweenbase_Pause (SdxMathTweenbase* self) {
	g_return_if_fail (self != NULL);
	self->isPaused = TRUE;
}


/**
         * Resumes the tween or timeline. Has no effect is it was no already paused.
         */
void sdx_math_tweenbase_Resume (SdxMathTweenbase* self) {
	g_return_if_fail (self != NULL);
	self->isPaused = FALSE;
}


/**
         * Repeats the tween or timeline for a given number of times.
         * @param count The number of repetitions. For infinite repetition,
         * use Tween.INFINITY, or a negative number.
         *
         * @param delay A delay between each iteration.
         * @return The current tween or timeline, for chaining instructions.
         */
SdxMathTweenbase* sdx_math_tweenbase_Repeat (SdxMathTweenbase* self, gint count, gfloat delay) {
	SdxMathTweenbase* result = NULL;
	gboolean _tmp0_;
	gint _tmp2_;
	gfloat _tmp3_ = 0.0F;
	gfloat _tmp4_;
	SdxMathTweenbase* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->isStarted;
	if (_tmp0_) {
		GError* _tmp1_;
		_tmp1_ = g_error_new_literal (SDX_EXCEPTION, SDX_EXCEPTION_RuntimeException, "You can't change the repetitions of a tween or timeline once it is sta" \
"rted");
		_inner_error_ = _tmp1_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = count;
	self->repeatCnt = _tmp2_;
	_tmp4_ = delay;
	if (_tmp4_ >= ((gfloat) 0)) {
		gfloat _tmp5_;
		_tmp5_ = delay;
		_tmp3_ = _tmp5_;
	} else {
		_tmp3_ = (gfloat) 0;
	}
	self->repeatDelay = _tmp3_;
	self->isYoyo = FALSE;
	_tmp6_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp6_;
	return result;
}


/**
         * Repeats the tween or timeline for a given number of times.
         * Every two iterations, it will be played backwards.
         *
         * @param count The number of repetitions. For infinite repetition,
         * use Tween.INFINITY, or '-1'.
         * @param delay A delay before each repetition.
         * @return The current tween or timeline, for chaining instructions.
         */
SdxMathTweenbase* sdx_math_tweenbase_RepeatYoyo (SdxMathTweenbase* self, gint count, gfloat delay) {
	SdxMathTweenbase* result = NULL;
	gboolean _tmp0_;
	gint _tmp2_;
	gfloat _tmp3_ = 0.0F;
	gfloat _tmp4_;
	SdxMathTweenbase* _tmp6_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->isStarted;
	if (_tmp0_) {
		GError* _tmp1_;
		_tmp1_ = g_error_new_literal (SDX_EXCEPTION, SDX_EXCEPTION_RuntimeException, "You can't change the repetitions of a tween or timeline once it is sta" \
"rted");
		_inner_error_ = _tmp1_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp2_ = count;
	self->repeatCnt = _tmp2_;
	_tmp4_ = delay;
	if (_tmp4_ >= ((gfloat) 0)) {
		gfloat _tmp5_;
		_tmp5_ = delay;
		_tmp3_ = _tmp5_;
	} else {
		_tmp3_ = (gfloat) 0;
	}
	self->repeatDelay = _tmp3_;
	self->isYoyo = TRUE;
	_tmp6_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp6_;
	return result;
}


/**
         * Sets the callback. By default, it will be fired at the completion of the
         * tween or timeline (event COMPLETE). If you want to change this behavior
         * and add more triggers, use the {@link SetCallbackTriggers} method.
         *
         * @see TweenCallback
         */
SdxMathTweenbase* sdx_math_tweenbase_SetCallback (SdxMathTweenbase* self, SdxMathTweenCallbackOnEvent callback, void* callback_target) {
	SdxMathTweenbase* result = NULL;
	SdxMathTweenCallbackOnEvent _tmp0_;
	void* _tmp0__target;
	SdxMathTweenbase* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = callback;
	_tmp0__target = callback_target;
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	self->callback = _tmp0_;
	self->callback_target = _tmp0__target;
	self->callback_target_destroy_notify = NULL;
	_tmp1_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp1_;
	return result;
}


/**
         * Changes the triggers of the callback. The available triggers, listed as
         * members of the {@link TweenCallback} interface, are:
         *
         *  * ''BEGIN'': right after the delay (if any)
         *  * ''START'': at each iteration beginning
         *  * ''END'': at each iteration ending, before the repeat delay
         *  * ''COMPLETE'': at last END event
         *  * ''BACK_BEGIN'': at the beginning of the first backward iteration
         *  * ''BACK_START'': at each backward iteration beginning, after the repeat delay
         *  * ''BACK_END'': at each backward iteration ending
         *  * ''BACK_COMPLETE'': at last BACK_END event
         *
         * {{{
         * forward :      BEGIN                                   COMPLETE
         * forward :      START    END      START    END      START    END
         * |--------------[XXXXXXXXXX]------[XXXXXXXXXX]------[XXXXXXXXXX]
         * backward:      bEND  bSTART      bEND  bSTART      bEND  bSTART
         * backward:      bCOMPLETE                                 bBEGIN
         * }}}
         *
         * @param flags one or more triggers, separated by the '|' operator.
         * @see TweenCallback
         */
SdxMathTweenbase* sdx_math_tweenbase_SetCallbackTriggers (SdxMathTweenbase* self, gint flags) {
	SdxMathTweenbase* result = NULL;
	gint _tmp0_;
	SdxMathTweenbase* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = flags;
	self->callbackTriggers = _tmp0_;
	_tmp1_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp1_;
	return result;
}


/**
         * Attaches an object to this tween or timeline. It can be useful in order
         * to retrieve some data from a TweenCallback.
         *
         * @param data Any kind of object.
         * @return The current tween or timeline, for chaining instructions.
         */
SdxMathTweenbase* sdx_math_tweenbase_SetUserData (SdxMathTweenbase* self, void* data) {
	SdxMathTweenbase* result = NULL;
	void* _tmp0_;
	SdxMathTweenbase* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = data;
	self->userData = _tmp0_;
	_tmp1_ = _sdx_math_tweenbase_retain0 (self);
	result = _tmp1_;
	return result;
}


/**
         * Gets the delay of the tween or timeline. Nothing will happen before
         * this delay.
         */
gfloat sdx_math_tweenbase_GetDelay (SdxMathTweenbase* self) {
	gfloat result = 0.0F;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->delay;
	result = _tmp0_;
	return result;
}


/**
         * Gets the duration of a single iteration.
         */
gfloat sdx_math_tweenbase_GetDuration (SdxMathTweenbase* self) {
	gfloat result = 0.0F;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->duration;
	result = _tmp0_;
	return result;
}


/**
         * Gets the number of iterations that will be played.
         */
gint sdx_math_tweenbase_GetRepeatCount (SdxMathTweenbase* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->repeatCnt;
	result = _tmp0_;
	return result;
}


/**
         * Gets the delay occuring between two iterations.
         */
gfloat sdx_math_tweenbase_GetRepeatDelay (SdxMathTweenbase* self) {
	gfloat result = 0.0F;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->repeatDelay;
	result = _tmp0_;
	return result;
}


/**
         * Returns the complete duration, including initial delay and repetitions.
         * The formula is as follows:
         * {{{
         * fullDuration = delay + duration + (repeatDelay + duration) * repeatCnt
         * }}}
         */
gfloat sdx_math_tweenbase_GetFullDuration (SdxMathTweenbase* self) {
	gfloat result = 0.0F;
	gint _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	gfloat _tmp3_;
	gfloat _tmp4_;
	gint _tmp5_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->repeatCnt;
	if (_tmp0_ < 0) {
		result = (gfloat) -1;
		return result;
	}
	_tmp1_ = self->delay;
	_tmp2_ = self->duration;
	_tmp3_ = self->repeatDelay;
	_tmp4_ = self->duration;
	_tmp5_ = self->repeatCnt;
	result = (_tmp1_ + _tmp2_) + ((_tmp3_ + _tmp4_) * _tmp5_);
	return result;
}


/**
         * Gets the attached data, or null if none.
         */
void* sdx_math_tweenbase_GetUserData (SdxMathTweenbase* self) {
	void* result = NULL;
	void* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->userData;
	result = _tmp0_;
	return result;
}


/**
         * Gets the id of the current step. Values are as follows:
         * 
         *  * even numbers mean that an iteration is playing,
         *  * odd numbers mean that we are between two iterations,
         *  * -2 means that the initial delay has not ended,
         *  * -1 means that we are before the first iteration,
         *  * repeatCount*2 + 1 means that we are after the last iteration
         */
gint sdx_math_tweenbase_GetStep (SdxMathTweenbase* self) {
	gint result = 0;
	gint _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->step;
	result = _tmp0_;
	return result;
}


/**
         * Gets the local time.
         */
gfloat sdx_math_tweenbase_GetCurrentTime (SdxMathTweenbase* self) {
	gfloat result = 0.0F;
	gfloat _tmp0_;
	g_return_val_if_fail (self != NULL, 0.0F);
	_tmp0_ = self->currentTime;
	result = _tmp0_;
	return result;
}


/**
         * Returns true if the tween or timeline has been started.
         */
gboolean sdx_math_tweenbase_IsStarted (SdxMathTweenbase* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->isStarted;
	result = _tmp0_;
	return result;
}


/**
         * Returns true if the tween or timeline has been initialized. Starting
         * values for tweens are stored at initialization time. This initialization
         * takes place right after the initial delay, if any.
         */
gboolean sdx_math_tweenbase_IsInitialized (SdxMathTweenbase* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->isInitialized;
	result = _tmp0_;
	return result;
}


/**
         * Returns true if the tween is finished (i.e. if the tween has reached
         * its end or has been killed). If you don't use a TweenManager, you may
         * want to call {@link Free} to reuse the object later.
         */
gboolean sdx_math_tweenbase_IsFinished (SdxMathTweenbase* self) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->isFinished;
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp2_;
		_tmp2_ = self->isKilled;
		_tmp0_ = _tmp2_;
	}
	result = _tmp0_;
	return result;
}


/**
         * Returns true if the iterations are played as yoyo. Yoyo means that
         * every two iterations, the animation will be played backwards.
         */
gboolean sdx_math_tweenbase_IsYoyo (SdxMathTweenbase* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->isYoyo;
	result = _tmp0_;
	return result;
}


/**
         * Returns true if the tween or timeline is currently paused.
         */
gboolean sdx_math_tweenbase_IsPaused (SdxMathTweenbase* self) {
	gboolean result = FALSE;
	gboolean _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->isPaused;
	result = _tmp0_;
	return result;
}


void sdx_math_tweenbase_ForceToStart (SdxMathTweenbase* self) {
	gfloat _tmp0_;
	gboolean _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->delay;
	self->currentTime = -_tmp0_;
	self->step = -1;
	self->isIterationStep = FALSE;
	_tmp1_ = sdx_math_tweenbase_IsReverse (self, 0);
	if (_tmp1_) {
		SdxMathTweenbaseTweenForceEndValues _tmp2_;
		void* _tmp2__target;
		_tmp2_ = self->ForceEndValues;
		_tmp2__target = self->ForceEndValues_target;
		_tmp2_ (_tmp2__target);
	} else {
		SdxMathTweenbaseTweenForceStartValues _tmp3_;
		void* _tmp3__target;
		_tmp3_ = self->ForceStartValues;
		_tmp3__target = self->ForceStartValues_target;
		_tmp3_ (_tmp3__target);
	}
}


void sdx_math_tweenbase_ForceToEnd (SdxMathTweenbase* self, gfloat time) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gboolean _tmp4_;
	g_return_if_fail (self != NULL);
	_tmp0_ = time;
	_tmp1_ = sdx_math_tweenbase_GetFullDuration (self);
	self->currentTime = _tmp0_ - _tmp1_;
	_tmp2_ = self->repeatCnt;
	self->step = (_tmp2_ * 2) + 1;
	self->isIterationStep = FALSE;
	_tmp3_ = self->repeatCnt;
	_tmp4_ = sdx_math_tweenbase_IsReverse (self, _tmp3_ * 2);
	if (_tmp4_) {
		SdxMathTweenbaseTweenForceStartValues _tmp5_;
		void* _tmp5__target;
		_tmp5_ = self->ForceStartValues;
		_tmp5__target = self->ForceStartValues_target;
		_tmp5_ (_tmp5__target);
	} else {
		SdxMathTweenbaseTweenForceEndValues _tmp6_;
		void* _tmp6__target;
		_tmp6_ = self->ForceEndValues;
		_tmp6__target = self->ForceEndValues_target;
		_tmp6_ (_tmp6__target);
	}
}


void sdx_math_tweenbase_CallCallback (SdxMathTweenbase* self, gint type) {
	gboolean _tmp0_ = FALSE;
	SdxMathTweenCallbackOnEvent _tmp1_;
	void* _tmp1__target;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->callback;
	_tmp1__target = self->callback_target;
	if (_tmp1_ != NULL) {
		gint _tmp2_;
		gint _tmp3_;
		_tmp2_ = self->callbackTriggers;
		_tmp3_ = type;
		_tmp0_ = (_tmp2_ & _tmp3_) > 0;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		SdxMathTweenCallbackOnEvent _tmp4_;
		void* _tmp4__target;
		gint _tmp5_;
		_tmp4_ = self->callback;
		_tmp4__target = self->callback_target;
		_tmp5_ = type;
		_tmp4_ (_tmp5_, self, _tmp4__target);
	}
}


gboolean sdx_math_tweenbase_IsReverse (SdxMathTweenbase* self, gint step) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp1_ = self->isYoyo;
	if (_tmp1_) {
		gint _tmp2_;
		gdouble _tmp3_;
		_tmp2_ = step;
		_tmp3_ = fabs ((gdouble) (_tmp2_ % 4));
		_tmp0_ = _tmp3_ == ((gdouble) 2);
	} else {
		_tmp0_ = FALSE;
	}
	result = _tmp0_;
	return result;
}


gboolean sdx_math_tweenbase_IsValid (SdxMathTweenbase* self, gint step) {
	gboolean result = FALSE;
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gint _tmp2_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp2_ = step;
	if (_tmp2_ >= 0) {
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = step;
		_tmp4_ = self->repeatCnt;
		_tmp1_ = _tmp3_ <= (_tmp4_ * 2);
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gint _tmp5_;
		_tmp5_ = self->repeatCnt;
		_tmp0_ = _tmp5_ < 0;
	}
	result = _tmp0_;
	return result;
}


void sdx_math_tweenbase_KillTarget (SdxMathTweenbase* self, void* target, gint tweenType) {
	SdxMathTweenbaseTweenContainsTarget _tmp0_;
	void* _tmp0__target;
	void* _tmp1_;
	gint _tmp2_;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->ContainsTarget;
	_tmp0__target = self->ContainsTarget_target;
	_tmp1_ = target;
	_tmp2_ = tweenType;
	_tmp3_ = _tmp0_ (_tmp1_, _tmp2_, _tmp0__target);
	if (_tmp3_) {
		sdx_math_tweenbase_Kill (self);
	}
}


/**
         * Updates the tween or timeline state. 
         * ''You may want to use a TweenManager to update objects for you.''
         *
         * Slow motion, fast motion and backward play can be easily achieved by
         * tweaking this delta time. Multiply it by -1 to play the animation
         * backward, or by 0.5 to play it twice slower than its normal speed.
         *
         * @param delta A delta time between now and the last call.
         */
void sdx_math_tweenbase_Update (SdxMathTweenbase* self, gfloat delta) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_;
	gfloat _tmp5_;
	gboolean _tmp6_;
	gboolean _tmp7_;
	gfloat _tmp8_;
	gfloat _tmp9_;
	g_return_if_fail (self != NULL);
	_tmp2_ = self->isStarted;
	if (!_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		gboolean _tmp3_;
		_tmp3_ = self->isPaused;
		_tmp1_ = _tmp3_;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		gboolean _tmp4_;
		_tmp4_ = self->isKilled;
		_tmp0_ = _tmp4_;
	}
	if (_tmp0_) {
		return;
	}
	_tmp5_ = delta;
	self->deltaTime = _tmp5_;
	_tmp6_ = self->isInitialized;
	if (!_tmp6_) {
		sdx_math_tweenbase_Initialize (self);
	}
	_tmp7_ = self->isInitialized;
	if (_tmp7_) {
		sdx_math_tweenbase_TestRelaunch (self);
		sdx_math_tweenbase_UpdateStep (self);
		sdx_math_tweenbase_TestCompletion (self);
	}
	_tmp8_ = self->currentTime;
	_tmp9_ = self->deltaTime;
	self->currentTime = _tmp8_ + _tmp9_;
	self->deltaTime = (gfloat) 0;
}


void sdx_math_tweenbase_Initialize (SdxMathTweenbase* self) {
	gfloat _tmp0_;
	gfloat _tmp1_;
	gfloat _tmp2_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->currentTime;
	_tmp1_ = self->deltaTime;
	_tmp2_ = self->delay;
	if ((_tmp0_ + _tmp1_) >= _tmp2_) {
		SdxMathTweenbaseTweenInitializeOverride _tmp3_;
		void* _tmp3__target;
		gfloat _tmp4_;
		gfloat _tmp5_;
		gfloat _tmp6_;
		_tmp3_ = self->InitializeOverride;
		_tmp3__target = self->InitializeOverride_target;
		_tmp3_ (_tmp3__target);
		self->isInitialized = TRUE;
		self->isIterationStep = TRUE;
		self->step = 0;
		_tmp4_ = self->deltaTime;
		_tmp5_ = self->delay;
		_tmp6_ = self->currentTime;
		self->deltaTime = _tmp4_ - (_tmp5_ - _tmp6_);
		self->currentTime = (gfloat) 0;
		sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BEGIN);
		sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START);
	}
}


void sdx_math_tweenbase_TestRelaunch (SdxMathTweenbase* self) {
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	gboolean _tmp3_;
	g_return_if_fail (self != NULL);
	_tmp3_ = self->isIterationStep;
	if (!_tmp3_) {
		gint _tmp4_;
		_tmp4_ = self->repeatCnt;
		_tmp2_ = _tmp4_ >= 0;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		gint _tmp5_;
		_tmp5_ = self->step;
		_tmp1_ = _tmp5_ < 0;
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		gfloat _tmp6_;
		gfloat _tmp7_;
		_tmp6_ = self->currentTime;
		_tmp7_ = self->deltaTime;
		_tmp0_ = (_tmp6_ + _tmp7_) >= ((gfloat) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		gint _tmp8_;
		gfloat delta = 0.0F;
		gfloat _tmp9_;
		gfloat _tmp10_;
		gfloat _tmp11_;
		SdxMathTweenbaseTweenUpdateOverride _tmp12_;
		void* _tmp12__target;
		gint _tmp13_;
		gint _tmp14_;
		gboolean _tmp15_;
		gfloat _tmp16_;
		_tmp8_ = self->step;
		_vala_assert (_tmp8_ == -1, "step == -1");
		self->isIterationStep = TRUE;
		self->step = 0;
		_tmp9_ = self->currentTime;
		delta = 0 - _tmp9_;
		_tmp10_ = self->deltaTime;
		_tmp11_ = delta;
		self->deltaTime = _tmp10_ - _tmp11_;
		self->currentTime = (gfloat) 0;
		sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BEGIN);
		sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START);
		_tmp12_ = self->UpdateOverride;
		_tmp12__target = self->UpdateOverride_target;
		_tmp13_ = self->step;
		_tmp14_ = self->step;
		_tmp15_ = self->isIterationStep;
		_tmp16_ = delta;
		_tmp12_ (_tmp13_, _tmp14_ - 1, _tmp15_, _tmp16_, _tmp12__target);
	} else {
		gboolean _tmp17_ = FALSE;
		gboolean _tmp18_ = FALSE;
		gboolean _tmp19_ = FALSE;
		gboolean _tmp20_;
		_tmp20_ = self->isIterationStep;
		if (!_tmp20_) {
			gint _tmp21_;
			_tmp21_ = self->repeatCnt;
			_tmp19_ = _tmp21_ >= 0;
		} else {
			_tmp19_ = FALSE;
		}
		if (_tmp19_) {
			gint _tmp22_;
			gint _tmp23_;
			_tmp22_ = self->step;
			_tmp23_ = self->repeatCnt;
			_tmp18_ = _tmp22_ > (_tmp23_ * 2);
		} else {
			_tmp18_ = FALSE;
		}
		if (_tmp18_) {
			gfloat _tmp24_;
			gfloat _tmp25_;
			_tmp24_ = self->currentTime;
			_tmp25_ = self->deltaTime;
			_tmp17_ = (_tmp24_ + _tmp25_) < ((gfloat) 0);
		} else {
			_tmp17_ = FALSE;
		}
		if (_tmp17_) {
			gint _tmp26_;
			gint _tmp27_;
			gint _tmp28_;
			gfloat delta = 0.0F;
			gfloat _tmp29_;
			gfloat _tmp30_;
			gfloat _tmp31_;
			gfloat _tmp32_;
			SdxMathTweenbaseTweenUpdateOverride _tmp33_;
			void* _tmp33__target;
			gint _tmp34_;
			gint _tmp35_;
			gboolean _tmp36_;
			gfloat _tmp37_;
			_tmp26_ = self->step;
			_tmp27_ = self->repeatCnt;
			_vala_assert (_tmp26_ == ((_tmp27_ * 2) + 1), "step == repeatCnt*2 + 1");
			self->isIterationStep = TRUE;
			_tmp28_ = self->repeatCnt;
			self->step = _tmp28_ * 2;
			_tmp29_ = self->currentTime;
			delta = 0 - _tmp29_;
			_tmp30_ = self->deltaTime;
			_tmp31_ = delta;
			self->deltaTime = _tmp30_ - _tmp31_;
			_tmp32_ = self->duration;
			self->currentTime = _tmp32_;
			sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_BEGIN);
			sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_START);
			_tmp33_ = self->UpdateOverride;
			_tmp33__target = self->UpdateOverride_target;
			_tmp34_ = self->step;
			_tmp35_ = self->step;
			_tmp36_ = self->isIterationStep;
			_tmp37_ = delta;
			_tmp33_ (_tmp34_, _tmp35_ + 1, _tmp36_, _tmp37_, _tmp33__target);
		}
	}
}


void sdx_math_tweenbase_UpdateStep (SdxMathTweenbase* self) {
	g_return_if_fail (self != NULL);
	while (TRUE) {
		gint _tmp0_;
		gboolean _tmp1_;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_;
		_tmp0_ = self->step;
		_tmp1_ = sdx_math_tweenbase_IsValid (self, _tmp0_);
		if (!_tmp1_) {
			break;
		}
		_tmp3_ = self->isIterationStep;
		if (!_tmp3_) {
			gfloat _tmp4_;
			gfloat _tmp5_;
			_tmp4_ = self->currentTime;
			_tmp5_ = self->deltaTime;
			_tmp2_ = (_tmp4_ + _tmp5_) <= ((gfloat) 0);
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			gint _tmp6_;
			gfloat delta = 0.0F;
			gfloat _tmp7_;
			gfloat _tmp8_;
			gfloat _tmp9_;
			gfloat _tmp10_;
			gint _tmp11_;
			gboolean _tmp12_;
			SdxMathTweenbaseTweenUpdateOverride _tmp15_;
			void* _tmp15__target;
			gint _tmp16_;
			gint _tmp17_;
			gboolean _tmp18_;
			gfloat _tmp19_;
			self->isIterationStep = TRUE;
			_tmp6_ = self->step;
			self->step = _tmp6_ - 1;
			_tmp7_ = self->currentTime;
			delta = 0 - _tmp7_;
			_tmp8_ = self->deltaTime;
			_tmp9_ = delta;
			self->deltaTime = _tmp8_ - _tmp9_;
			_tmp10_ = self->duration;
			self->currentTime = _tmp10_;
			_tmp11_ = self->step;
			_tmp12_ = sdx_math_tweenbase_IsReverse (self, _tmp11_);
			if (_tmp12_) {
				SdxMathTweenbaseTweenForceStartValues _tmp13_;
				void* _tmp13__target;
				_tmp13_ = self->ForceStartValues;
				_tmp13__target = self->ForceStartValues_target;
				_tmp13_ (_tmp13__target);
			} else {
				SdxMathTweenbaseTweenForceEndValues _tmp14_;
				void* _tmp14__target;
				_tmp14_ = self->ForceEndValues;
				_tmp14__target = self->ForceEndValues_target;
				_tmp14_ (_tmp14__target);
			}
			sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_START);
			_tmp15_ = self->UpdateOverride;
			_tmp15__target = self->UpdateOverride_target;
			_tmp16_ = self->step;
			_tmp17_ = self->step;
			_tmp18_ = self->isIterationStep;
			_tmp19_ = delta;
			_tmp15_ (_tmp16_, _tmp17_ + 1, _tmp18_, _tmp19_, _tmp15__target);
		} else {
			gboolean _tmp20_ = FALSE;
			gboolean _tmp21_;
			_tmp21_ = self->isIterationStep;
			if (!_tmp21_) {
				gfloat _tmp22_;
				gfloat _tmp23_;
				gfloat _tmp24_;
				_tmp22_ = self->currentTime;
				_tmp23_ = self->deltaTime;
				_tmp24_ = self->repeatDelay;
				_tmp20_ = (_tmp22_ + _tmp23_) >= _tmp24_;
			} else {
				_tmp20_ = FALSE;
			}
			if (_tmp20_) {
				gint _tmp25_;
				gfloat delta = 0.0F;
				gfloat _tmp26_;
				gfloat _tmp27_;
				gfloat _tmp28_;
				gfloat _tmp29_;
				gint _tmp30_;
				gboolean _tmp31_;
				SdxMathTweenbaseTweenUpdateOverride _tmp34_;
				void* _tmp34__target;
				gint _tmp35_;
				gint _tmp36_;
				gboolean _tmp37_;
				gfloat _tmp38_;
				self->isIterationStep = TRUE;
				_tmp25_ = self->step;
				self->step = _tmp25_ + 1;
				_tmp26_ = self->repeatDelay;
				_tmp27_ = self->currentTime;
				delta = _tmp26_ - _tmp27_;
				_tmp28_ = self->deltaTime;
				_tmp29_ = delta;
				self->deltaTime = _tmp28_ - _tmp29_;
				self->currentTime = (gfloat) 0;
				_tmp30_ = self->step;
				_tmp31_ = sdx_math_tweenbase_IsReverse (self, _tmp30_);
				if (_tmp31_) {
					SdxMathTweenbaseTweenForceEndValues _tmp32_;
					void* _tmp32__target;
					_tmp32_ = self->ForceEndValues;
					_tmp32__target = self->ForceEndValues_target;
					_tmp32_ (_tmp32__target);
				} else {
					SdxMathTweenbaseTweenForceStartValues _tmp33_;
					void* _tmp33__target;
					_tmp33_ = self->ForceStartValues;
					_tmp33__target = self->ForceStartValues_target;
					_tmp33_ (_tmp33__target);
				}
				sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_START);
				_tmp34_ = self->UpdateOverride;
				_tmp34__target = self->UpdateOverride_target;
				_tmp35_ = self->step;
				_tmp36_ = self->step;
				_tmp37_ = self->isIterationStep;
				_tmp38_ = delta;
				_tmp34_ (_tmp35_, _tmp36_ - 1, _tmp37_, _tmp38_, _tmp34__target);
			} else {
				gboolean _tmp39_ = FALSE;
				gboolean _tmp40_;
				_tmp40_ = self->isIterationStep;
				if (_tmp40_) {
					gfloat _tmp41_;
					gfloat _tmp42_;
					_tmp41_ = self->currentTime;
					_tmp42_ = self->deltaTime;
					_tmp39_ = (_tmp41_ + _tmp42_) < ((gfloat) 0);
				} else {
					_tmp39_ = FALSE;
				}
				if (_tmp39_) {
					gint _tmp43_;
					gfloat delta = 0.0F;
					gfloat _tmp44_;
					gfloat _tmp45_;
					gfloat _tmp46_;
					SdxMathTweenbaseTweenUpdateOverride _tmp47_;
					void* _tmp47__target;
					gint _tmp48_;
					gint _tmp49_;
					gboolean _tmp50_;
					gfloat _tmp51_;
					gboolean _tmp52_ = FALSE;
					gint _tmp53_;
					self->isIterationStep = FALSE;
					_tmp43_ = self->step;
					self->step = _tmp43_ - 1;
					_tmp44_ = self->currentTime;
					delta = 0 - _tmp44_;
					_tmp45_ = self->deltaTime;
					_tmp46_ = delta;
					self->deltaTime = _tmp45_ - _tmp46_;
					self->currentTime = (gfloat) 0;
					_tmp47_ = self->UpdateOverride;
					_tmp47__target = self->UpdateOverride_target;
					_tmp48_ = self->step;
					_tmp49_ = self->step;
					_tmp50_ = self->isIterationStep;
					_tmp51_ = delta;
					_tmp47_ (_tmp48_, _tmp49_ + 1, _tmp50_, _tmp51_, _tmp47__target);
					sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_END);
					_tmp53_ = self->step;
					if (_tmp53_ < 0) {
						gint _tmp54_;
						_tmp54_ = self->repeatCnt;
						_tmp52_ = _tmp54_ >= 0;
					} else {
						_tmp52_ = FALSE;
					}
					if (_tmp52_) {
						sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_BACK_COMPLETE);
					} else {
						gfloat _tmp55_;
						_tmp55_ = self->repeatDelay;
						self->currentTime = _tmp55_;
					}
				} else {
					gboolean _tmp56_ = FALSE;
					gboolean _tmp57_;
					_tmp57_ = self->isIterationStep;
					if (_tmp57_) {
						gfloat _tmp58_;
						gfloat _tmp59_;
						gfloat _tmp60_;
						_tmp58_ = self->currentTime;
						_tmp59_ = self->deltaTime;
						_tmp60_ = self->duration;
						_tmp56_ = (_tmp58_ + _tmp59_) > _tmp60_;
					} else {
						_tmp56_ = FALSE;
					}
					if (_tmp56_) {
						gint _tmp61_;
						gfloat delta = 0.0F;
						gfloat _tmp62_;
						gfloat _tmp63_;
						gfloat _tmp64_;
						gfloat _tmp65_;
						gfloat _tmp66_;
						SdxMathTweenbaseTweenUpdateOverride _tmp67_;
						void* _tmp67__target;
						gint _tmp68_;
						gint _tmp69_;
						gboolean _tmp70_;
						gfloat _tmp71_;
						gboolean _tmp72_ = FALSE;
						gint _tmp73_;
						gint _tmp74_;
						self->isIterationStep = FALSE;
						_tmp61_ = self->step;
						self->step = _tmp61_ + 1;
						_tmp62_ = self->duration;
						_tmp63_ = self->currentTime;
						delta = _tmp62_ - _tmp63_;
						_tmp64_ = self->deltaTime;
						_tmp65_ = delta;
						self->deltaTime = _tmp64_ - _tmp65_;
						_tmp66_ = self->duration;
						self->currentTime = _tmp66_;
						_tmp67_ = self->UpdateOverride;
						_tmp67__target = self->UpdateOverride_target;
						_tmp68_ = self->step;
						_tmp69_ = self->step;
						_tmp70_ = self->isIterationStep;
						_tmp71_ = delta;
						_tmp67_ (_tmp68_, _tmp69_ - 1, _tmp70_, _tmp71_, _tmp67__target);
						sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_END);
						_tmp73_ = self->step;
						_tmp74_ = self->repeatCnt;
						if (_tmp73_ > (_tmp74_ * 2)) {
							gint _tmp75_;
							_tmp75_ = self->repeatCnt;
							_tmp72_ = _tmp75_ >= 0;
						} else {
							_tmp72_ = FALSE;
						}
						if (_tmp72_) {
							sdx_math_tweenbase_CallCallback (self, (gint) SDX_MATH_TWEENBASE_TWEEN_CALLBACK_COMPLETE);
						}
						self->currentTime = (gfloat) 0;
					} else {
						gboolean _tmp76_;
						_tmp76_ = self->isIterationStep;
						if (_tmp76_) {
							gfloat delta = 0.0F;
							gfloat _tmp77_;
							gfloat _tmp78_;
							gfloat _tmp79_;
							gfloat _tmp80_;
							gfloat _tmp81_;
							SdxMathTweenbaseTweenUpdateOverride _tmp82_;
							void* _tmp82__target;
							gint _tmp83_;
							gint _tmp84_;
							gboolean _tmp85_;
							gfloat _tmp86_;
							_tmp77_ = self->deltaTime;
							delta = _tmp77_;
							_tmp78_ = self->deltaTime;
							_tmp79_ = delta;
							self->deltaTime = _tmp78_ - _tmp79_;
							_tmp80_ = self->currentTime;
							_tmp81_ = delta;
							self->currentTime = _tmp80_ + _tmp81_;
							_tmp82_ = self->UpdateOverride;
							_tmp82__target = self->UpdateOverride_target;
							_tmp83_ = self->step;
							_tmp84_ = self->step;
							_tmp85_ = self->isIterationStep;
							_tmp86_ = delta;
							_tmp82_ (_tmp83_, _tmp84_, _tmp85_, _tmp86_, _tmp82__target);
							break;
						} else {
							gfloat delta = 0.0F;
							gfloat _tmp87_;
							gfloat _tmp88_;
							gfloat _tmp89_;
							gfloat _tmp90_;
							gfloat _tmp91_;
							_tmp87_ = self->deltaTime;
							delta = _tmp87_;
							_tmp88_ = self->deltaTime;
							_tmp89_ = delta;
							self->deltaTime = _tmp88_ - _tmp89_;
							_tmp90_ = self->currentTime;
							_tmp91_ = delta;
							self->currentTime = _tmp90_ + _tmp91_;
							break;
						}
					}
				}
			}
		}
	}
}


void sdx_math_tweenbase_TestCompletion (SdxMathTweenbase* self) {
	gboolean _tmp0_ = FALSE;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp1_ = self->repeatCnt;
	if (_tmp1_ >= 0) {
		gboolean _tmp2_ = FALSE;
		gint _tmp3_;
		gint _tmp4_;
		_tmp3_ = self->step;
		_tmp4_ = self->repeatCnt;
		if (_tmp3_ > (_tmp4_ * 2)) {
			_tmp2_ = TRUE;
		} else {
			gint _tmp5_;
			_tmp5_ = self->step;
			_tmp2_ = _tmp5_ < 0;
		}
		_tmp0_ = _tmp2_;
	} else {
		_tmp0_ = FALSE;
	}
	self->isFinished = _tmp0_;
}


static void sdx_math_tweenbase_instance_init (SdxMathTweenbase * self) {
	gint _tmp0_;
	gfloat* _tmp1_;
	gint _tmp2_;
	gfloat* _tmp3_;
	gint _tmp4_;
	gfloat* _tmp5_;
	self->ref_count = 1;
	_tmp0_ = sdx_math_tweenbase_combinedAttrsLimit;
	_tmp1_ = g_new0 (gfloat, _tmp0_);
	self->startValues = _tmp1_;
	self->startValues_length1 = _tmp0_;
	_tmp2_ = sdx_math_tweenbase_combinedAttrsLimit;
	_tmp3_ = g_new0 (gfloat, _tmp2_);
	self->targetValues = _tmp3_;
	self->targetValues_length1 = _tmp2_;
	_tmp4_ = sdx_math_tweenbase_combinedAttrsLimit;
	_tmp5_ = g_new0 (gfloat, _tmp4_);
	self->accessorBuffer = _tmp5_;
	self->accessorBuffer_length1 = _tmp4_;
	self->Reset = __sdx_math_tweenbase_reset_lambda75__sdx_math_tweenbase_tween_reset;
	self->Reset_target = self;
	self->Reset_target_destroy_notify = NULL;
	self->Build = __sdx_math_tweenbase_build_lambda76__sdx_math_tweenbase_tween_build;
	self->Build_target = self;
	self->Build_target_destroy_notify = NULL;
	self->Free = __sdx_math_tweenbase_free_lambda77__sdx_math_tweenbase_tween_free;
	self->Free_target = self;
	self->Free_target_destroy_notify = NULL;
	self->Start = __sdx_math_tweenbase_start_lambda91__sdx_math_tweenbase_tween_start;
	self->Start_target = self;
	self->Start_target_destroy_notify = NULL;
	self->ForceStartValues = __sdx_math_tweenbase_force_start_values_lambda84__sdx_math_tweenbase_tween_force_start_values;
	self->ForceStartValues_target = self;
	self->ForceStartValues_target_destroy_notify = NULL;
	self->ForceEndValues = __sdx_math_tweenbase_force_end_values_lambda86__sdx_math_tweenbase_tween_force_end_values;
	self->ForceEndValues_target = self;
	self->ForceEndValues_target_destroy_notify = NULL;
	self->ContainsTarget = __sdx_math_tweenbase_contains_target_lambda88__sdx_math_tweenbase_tween_contains_target;
	self->ContainsTarget_target = self;
	self->ContainsTarget_target_destroy_notify = NULL;
	self->InitializeOverride = __sdx_math_tweenbase_initialize_override_lambda80__sdx_math_tweenbase_tween_initialize_override;
	self->InitializeOverride_target = self;
	self->InitializeOverride_target_destroy_notify = NULL;
	self->UpdateOverride = __sdx_math_tweenbase_update_override_lambda82__sdx_math_tweenbase_tween_update_override;
	self->UpdateOverride_target = self;
	self->UpdateOverride_target_destroy_notify = NULL;
}


void sdx_math_tweenbase_free (SdxMathTweenbase * self) {
	(self->callback_target_destroy_notify == NULL) ? NULL : (self->callback_target_destroy_notify (self->callback_target), NULL);
	self->callback = NULL;
	self->callback_target = NULL;
	self->callback_target_destroy_notify = NULL;
	_sdx_math_tween_accessor_release0 (self->accessor);
	_sdx_math_interpolation_release0 (self->equation);
	self->startValues = (g_free (self->startValues), NULL);
	self->targetValues = (g_free (self->targetValues), NULL);
	self->accessorBuffer = (g_free (self->accessorBuffer), NULL);
	_g_ptr_array_unref0 (self->children);
	_sdx_math_tweenbase_release0 (self->current);
	_sdx_math_tweenbase_release0 (self->parent);
	(self->Reset_target_destroy_notify == NULL) ? NULL : (self->Reset_target_destroy_notify (self->Reset_target), NULL);
	self->Reset = NULL;
	self->Reset_target = NULL;
	self->Reset_target_destroy_notify = NULL;
	(self->Build_target_destroy_notify == NULL) ? NULL : (self->Build_target_destroy_notify (self->Build_target), NULL);
	self->Build = NULL;
	self->Build_target = NULL;
	self->Build_target_destroy_notify = NULL;
	(self->Free_target_destroy_notify == NULL) ? NULL : (self->Free_target_destroy_notify (self->Free_target), NULL);
	self->Free = NULL;
	self->Free_target = NULL;
	self->Free_target_destroy_notify = NULL;
	(self->Start_target_destroy_notify == NULL) ? NULL : (self->Start_target_destroy_notify (self->Start_target), NULL);
	self->Start = NULL;
	self->Start_target = NULL;
	self->Start_target_destroy_notify = NULL;
	(self->ForceStartValues_target_destroy_notify == NULL) ? NULL : (self->ForceStartValues_target_destroy_notify (self->ForceStartValues_target), NULL);
	self->ForceStartValues = NULL;
	self->ForceStartValues_target = NULL;
	self->ForceStartValues_target_destroy_notify = NULL;
	(self->ForceEndValues_target_destroy_notify == NULL) ? NULL : (self->ForceEndValues_target_destroy_notify (self->ForceEndValues_target), NULL);
	self->ForceEndValues = NULL;
	self->ForceEndValues_target = NULL;
	self->ForceEndValues_target_destroy_notify = NULL;
	(self->ContainsTarget_target_destroy_notify == NULL) ? NULL : (self->ContainsTarget_target_destroy_notify (self->ContainsTarget_target), NULL);
	self->ContainsTarget = NULL;
	self->ContainsTarget_target = NULL;
	self->ContainsTarget_target_destroy_notify = NULL;
	(self->InitializeOverride_target_destroy_notify == NULL) ? NULL : (self->InitializeOverride_target_destroy_notify (self->InitializeOverride_target), NULL);
	self->InitializeOverride = NULL;
	self->InitializeOverride_target = NULL;
	self->InitializeOverride_target_destroy_notify = NULL;
	(self->UpdateOverride_target_destroy_notify == NULL) ? NULL : (self->UpdateOverride_target_destroy_notify (self->UpdateOverride_target), NULL);
	self->UpdateOverride = NULL;
	self->UpdateOverride_target = NULL;
	self->UpdateOverride_target_destroy_notify = NULL;
	g_slice_free (SdxMathTweenbase, self);
}





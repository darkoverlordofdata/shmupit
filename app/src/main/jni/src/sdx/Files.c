/** updated by adriac */
/* Files.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Files.vala, do not modify */

/*[Adriac:Sdx::DataInputStream:SdxDataInputStream:sdx_data_input_stream]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>


#define SDX_TYPE_FILE_TYPE (sdx_file_type_get_type ())
typedef struct _SdxDataInputStream SdxDataInputStream;

typedef enum  {
	SDX_FILE_TYPE_Resource = 1,
	SDX_FILE_TYPE_Asset,
	SDX_FILE_TYPE_Absolute,
	SDX_FILE_TYPE_Relative
} SdxFileType;

struct _SdxDataInputStream {
	gint ref_count;
	gchar** data;
	gint data_length1;
	gint ctr;
};



GType sdx_file_type_get_type (void) G_GNUC_CONST;
void sdx_data_input_stream_free (SdxDataInputStream * self);
static void sdx_data_input_stream_instance_init (SdxDataInputStream * self);
SdxDataInputStream* sdx_data_input_stream_retain (SdxDataInputStream* self);
void sdx_data_input_stream_release (SdxDataInputStream* self);
void sdx_data_input_stream_free (SdxDataInputStream* self);
SdxDataInputStream* sdx_data_input_stream_new (const gchar* data);
gchar* sdx_data_input_stream_ReadLine (SdxDataInputStream* self);
static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func);
static gint _vala_array_length (gpointer array);


GType sdx_file_type_get_type (void) {
	static volatile gsize sdx_file_type_type_id__volatile = 0;
	if (g_once_init_enter (&sdx_file_type_type_id__volatile)) {
		static const GEnumValue values[] = {{SDX_FILE_TYPE_Resource, "SDX_FILE_TYPE_Resource", "resource"}, {SDX_FILE_TYPE_Asset, "SDX_FILE_TYPE_Asset", "asset"}, {SDX_FILE_TYPE_Absolute, "SDX_FILE_TYPE_Absolute", "absolute"}, {SDX_FILE_TYPE_Relative, "SDX_FILE_TYPE_Relative", "relative"}, {0, NULL, NULL}};
		GType sdx_file_type_type_id;
		sdx_file_type_type_id = g_enum_register_static ("SdxFileType", values);
		g_once_init_leave (&sdx_file_type_type_id__volatile, sdx_file_type_type_id);
	}
	return sdx_file_type_type_id__volatile;
}


SdxDataInputStream* sdx_data_input_stream_retain (SdxDataInputStream* self) {
	SdxDataInputStream* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_data_input_stream_release (SdxDataInputStream* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_data_input_stream_free (self);
	}
}


SdxDataInputStream* sdx_data_input_stream_new (const gchar* data) {
	SdxDataInputStream* self;
	const gchar* _tmp0_;
	gchar** _tmp1_;
	gchar** _tmp2_;
	g_return_val_if_fail (data != NULL, NULL);
	self = g_slice_new0 (SdxDataInputStream);
	sdx_data_input_stream_instance_init (self);
	_tmp0_ = data;
	_tmp2_ = _tmp1_ = g_strsplit (_tmp0_, "\n", 0);
	self->data = (_vala_array_free (self->data, self->data_length1, (GDestroyNotify) g_free), NULL);
	self->data = _tmp2_;
	self->data_length1 = _vala_array_length (_tmp1_);
	self->ctr = 0;
	return self;
}


gchar* sdx_data_input_stream_ReadLine (SdxDataInputStream* self) {
	gchar* result = NULL;
	const gchar* _tmp0_ = NULL;
	gint _tmp1_;
	gchar** _tmp2_;
	gint _tmp2__length1;
	gchar* _tmp6_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = self->ctr;
	_tmp2_ = self->data;
	_tmp2__length1 = self->data_length1;
	if (_tmp1_ < _tmp2__length1) {
		gchar** _tmp3_;
		gint _tmp3__length1;
		gint _tmp4_;
		const gchar* _tmp5_;
		_tmp3_ = self->data;
		_tmp3__length1 = self->data_length1;
		_tmp4_ = self->ctr;
		self->ctr = _tmp4_ + 1;
		_tmp5_ = _tmp3_[_tmp4_];
		_tmp0_ = _tmp5_;
	} else {
		_tmp0_ = NULL;
	}
	_tmp6_ = g_strdup (_tmp0_);
	result = _tmp6_;
	return result;
}


static void sdx_data_input_stream_instance_init (SdxDataInputStream * self) {
	self->ref_count = 1;
}


void sdx_data_input_stream_free (SdxDataInputStream * self) {
	self->data = (_vala_array_free (self->data, self->data_length1, (GDestroyNotify) g_free), NULL);
	g_slice_free (SdxDataInputStream, self);
}


static void _vala_array_destroy (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	if ((array != NULL) && (destroy_func != NULL)) {
		int i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}


static void _vala_array_free (gpointer array, gint array_length, GDestroyNotify destroy_func) {
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}


static gint _vala_array_length (gpointer array) {
	int length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}





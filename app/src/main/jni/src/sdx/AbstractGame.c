/** updated by adriac */
/* AbstractGame.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from AbstractGame.vala, do not modify */

/*[Adriac:Sdx::AbstractPlatform:SdxAbstractPlatform:sdx_abstract_platform]*/
/*[Adriac:Sdx::AbstractGame:SdxAbstractGame:sdx_abstract_game]*/
/*[Adriac:Sdx::AbstractReference:SdxAbstractReference:sdx_abstract_reference]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>

typedef struct _SdxAbstractReference SdxAbstractReference;
typedef struct _SdxAbstractGame SdxAbstractGame;
// symtbl.1 sdx_abstract_reference
void sdx_abstract_reference_release (SdxAbstractReference* self);
void sdx_abstract_reference_free (SdxAbstractReference* self);
SdxAbstractReference* sdx_abstract_reference_retain (SdxAbstractReference* self);
#define _sdx_abstract_reference_release0(var) ((var == NULL) ? NULL : (var = (sdx_abstract_reference_release (var), NULL)))
typedef struct _SdxAbstractPlatform SdxAbstractPlatform;

struct _SdxAbstractReference {
	gint ref_count;
};

typedef void (*SdxAbstractGameAbstractUpdate) (void* user_data);
typedef void (*SdxAbstractGameAbstractDraw) (void* user_data);
struct _SdxAbstractGame {
	gint ref_count;
	gint width;
	gint height;
	SdxAbstractGameAbstractUpdate Update;
	gpointer Update_target;
	GDestroyNotify Update_target_destroy_notify;
	SdxAbstractGameAbstractDraw Draw;
	gpointer Draw_target;
	GDestroyNotify Draw_target_destroy_notify;
};

typedef void (*SdxAbstractPlatformAbstractUpdate) (gint tick, void* user_data);
typedef void (*SdxAbstractPlatformAbstractDraw) (gint tick, void* user_data);
struct _SdxAbstractPlatform {
	gint ref_count;
	gint width;
	gint height;
	SdxAbstractPlatformAbstractUpdate Update;
	gpointer Update_target;
	GDestroyNotify Update_target_destroy_notify;
	SdxAbstractPlatformAbstractDraw Draw;
	gpointer Draw_target;
	GDestroyNotify Draw_target_destroy_notify;
};



void sdx_abstract_reference_free (SdxAbstractReference * self);
static void sdx_abstract_reference_instance_init (SdxAbstractReference * self);
SdxAbstractReference* sdx_abstract_reference_retain (SdxAbstractReference* self);
void sdx_abstract_reference_release (SdxAbstractReference* self);
void sdx_abstract_reference_free (SdxAbstractReference* self);
SdxAbstractReference* sdx_abstract_reference_new (void);
void sdx_abstract_game_free (SdxAbstractGame * self);
static void sdx_abstract_game_instance_init (SdxAbstractGame * self);
static void _sdx_abstract_game_update_lambda27_ (void);
static void __sdx_abstract_game_update_lambda27__sdx_abstract_game_abstract_update (gpointer self);
static void _sdx_abstract_game_draw_lambda28_ (void);
static void __sdx_abstract_game_draw_lambda28__sdx_abstract_game_abstract_draw (gpointer self);
SdxAbstractGame* sdx_abstract_game_retain (SdxAbstractGame* self);
void sdx_abstract_game_release (SdxAbstractGame* self);
void sdx_abstract_game_free (SdxAbstractGame* self);
SdxAbstractGame* sdx_abstract_game_new (void);
void sdx_abstract_game_Start (SdxAbstractGame* self);
void sdx_Start (void);
void sdx_abstract_platform_free (SdxAbstractPlatform * self);
static void sdx_abstract_platform_instance_init (SdxAbstractPlatform * self);
static void _sdx_abstract_platform_update_lambda29_ (gint tick);
static void __sdx_abstract_platform_update_lambda29__sdx_abstract_platform_abstract_update (gint tick, gpointer self);
static void _sdx_abstract_platform_draw_lambda30_ (gint tick);
static void __sdx_abstract_platform_draw_lambda30__sdx_abstract_platform_abstract_draw (gint tick, gpointer self);
SdxAbstractPlatform* sdx_abstract_platform_retain (SdxAbstractPlatform* self);
void sdx_abstract_platform_release (SdxAbstractPlatform* self);
void sdx_abstract_platform_free (SdxAbstractPlatform* self);
SdxAbstractPlatform* sdx_abstract_platform_new (void);


SdxAbstractReference* sdx_abstract_reference_retain (SdxAbstractReference* self) {
	SdxAbstractReference* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_abstract_reference_release (SdxAbstractReference* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_abstract_reference_free (self);
	}
}


SdxAbstractReference* sdx_abstract_reference_new (void) {
	SdxAbstractReference* self;
	self = g_slice_new0 (SdxAbstractReference);
	sdx_abstract_reference_instance_init (self);
	return self;
}


static void sdx_abstract_reference_instance_init (SdxAbstractReference * self) {
	self->ref_count = 1;
}


void sdx_abstract_reference_free (SdxAbstractReference * self) {
	g_slice_free (SdxAbstractReference, self);
}


static void _sdx_abstract_game_update_lambda27_ (void) {
}


static void __sdx_abstract_game_update_lambda27__sdx_abstract_game_abstract_update (gpointer self) {
	_sdx_abstract_game_update_lambda27_ ();
}


static void _sdx_abstract_game_draw_lambda28_ (void) {
}


static void __sdx_abstract_game_draw_lambda28__sdx_abstract_game_abstract_draw (gpointer self) {
	_sdx_abstract_game_draw_lambda28_ ();
}


SdxAbstractGame* sdx_abstract_game_retain (SdxAbstractGame* self) {
	SdxAbstractGame* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_abstract_game_release (SdxAbstractGame* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_abstract_game_free (self);
	}
}


SdxAbstractGame* sdx_abstract_game_new (void) {
	SdxAbstractGame* self;
	SdxAbstractReference* r = NULL;
	SdxAbstractReference* _tmp0_;
	self = g_slice_new0 (SdxAbstractGame);
	sdx_abstract_game_instance_init (self);
	_tmp0_ = sdx_abstract_reference_new ();
	r = _tmp0_;
	_sdx_abstract_reference_release0 (r);
	return self;
}


void sdx_abstract_game_Start (SdxAbstractGame* self) {
	g_return_if_fail (self != NULL);
	sdx_Start ();
}


static void sdx_abstract_game_instance_init (SdxAbstractGame * self) {
	self->ref_count = 1;
	self->Update = __sdx_abstract_game_update_lambda27__sdx_abstract_game_abstract_update;
	self->Update_target = self;
	self->Update_target_destroy_notify = NULL;
	self->Draw = __sdx_abstract_game_draw_lambda28__sdx_abstract_game_abstract_draw;
	self->Draw_target = self;
	self->Draw_target_destroy_notify = NULL;
}


void sdx_abstract_game_free (SdxAbstractGame * self) {
	(self->Update_target_destroy_notify == NULL) ? NULL : (self->Update_target_destroy_notify (self->Update_target), NULL);
	self->Update = NULL;
	self->Update_target = NULL;
	self->Update_target_destroy_notify = NULL;
	(self->Draw_target_destroy_notify == NULL) ? NULL : (self->Draw_target_destroy_notify (self->Draw_target), NULL);
	self->Draw = NULL;
	self->Draw_target = NULL;
	self->Draw_target_destroy_notify = NULL;
	g_slice_free (SdxAbstractGame, self);
}


static void _sdx_abstract_platform_update_lambda29_ (gint tick) {
}


static void __sdx_abstract_platform_update_lambda29__sdx_abstract_platform_abstract_update (gint tick, gpointer self) {
	_sdx_abstract_platform_update_lambda29_ (tick);
}


static void _sdx_abstract_platform_draw_lambda30_ (gint tick) {
}


static void __sdx_abstract_platform_draw_lambda30__sdx_abstract_platform_abstract_draw (gint tick, gpointer self) {
	_sdx_abstract_platform_draw_lambda30_ (tick);
}


SdxAbstractPlatform* sdx_abstract_platform_retain (SdxAbstractPlatform* self) {
	SdxAbstractPlatform* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_abstract_platform_release (SdxAbstractPlatform* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_abstract_platform_free (self);
	}
}


SdxAbstractPlatform* sdx_abstract_platform_new (void) {
	SdxAbstractPlatform* self;
	SdxAbstractReference* r = NULL;
	SdxAbstractReference* _tmp0_;
	self = g_slice_new0 (SdxAbstractPlatform);
	sdx_abstract_platform_instance_init (self);
	_tmp0_ = sdx_abstract_reference_new ();
	r = _tmp0_;
	_sdx_abstract_reference_release0 (r);
	return self;
}


static void sdx_abstract_platform_instance_init (SdxAbstractPlatform * self) {
	self->ref_count = 1;
	self->Update = __sdx_abstract_platform_update_lambda29__sdx_abstract_platform_abstract_update;
	self->Update_target = self;
	self->Update_target_destroy_notify = NULL;
	self->Draw = __sdx_abstract_platform_draw_lambda30__sdx_abstract_platform_abstract_draw;
	self->Draw_target = self;
	self->Draw_target_destroy_notify = NULL;
}


void sdx_abstract_platform_free (SdxAbstractPlatform * self) {
	(self->Update_target_destroy_notify == NULL) ? NULL : (self->Update_target_destroy_notify (self->Update_target), NULL);
	self->Update = NULL;
	self->Update_target = NULL;
	self->Update_target_destroy_notify = NULL;
	(self->Draw_target_destroy_notify == NULL) ? NULL : (self->Draw_target_destroy_notify (self->Draw_target), NULL);
	self->Draw = NULL;
	self->Draw_target = NULL;
	self->Draw_target_destroy_notify = NULL;
	g_slice_free (SdxAbstractPlatform, self);
}





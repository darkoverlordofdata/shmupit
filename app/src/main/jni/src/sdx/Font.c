/** updated by adriac */
/* Font.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Font.vala, do not modify */

/*[Adriac:Sdx::Font:SdxFont:sdx_font]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <SDL_ttf.h>
#include <SDL_rwops.h>
#include <SDL_pixels.h>
#include <SDL_surface.h>

typedef struct _SdxFont SdxFont;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _TTF_CloseFont0(var) ((var == NULL) ? NULL : (var = (TTF_CloseFont (var), NULL)))
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))
typedef struct _SdxFilesFileHandle SdxFilesFileHandle;
// symtbl.1 sdx_files_file_handle
void sdx_files_file_handle_release (SdxFilesFileHandle* self);
void sdx_files_file_handle_free (SdxFilesFileHandle* self);
SdxFilesFileHandle* sdx_files_file_handle_retain (SdxFilesFileHandle* self);
#define _sdx_files_file_handle_release0(var) ((var == NULL) ? NULL : (var = (sdx_files_file_handle_release (var), NULL)))

struct _SdxFont {
	gint ref_count;
	gint id;
	gchar* path;
	gint size;
	TTF_Font* innerFont;
	SDL_RWops* raw;
};


extern gint sdx_font_uniqueId;
gint sdx_font_uniqueId = 0;

void sdx_font_free (SdxFont * self);
static void sdx_font_instance_init (SdxFont * self);
SdxFont* sdx_font_retain (SdxFont* self);
void sdx_font_release (SdxFont* self);
void sdx_font_free (SdxFont* self);
SdxFont* sdx_font_new (const gchar* path, gint size);
void sdx_files_file_handle_free (SdxFilesFileHandle * self);
SdxFilesFileHandle* sdx_files_Default (const gchar* path);
SDL_RWops* sdx_files_file_handle_GetRWops (SdxFilesFileHandle* self);
SDL_Surface* sdx_font_Render (SdxFont* self, const gchar* text, SDL_Color fg, SDL_Color* bg);


SdxFont* sdx_font_retain (SdxFont* self) {
	SdxFont* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_font_release (SdxFont* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_font_free (self);
	}
}


SdxFont* sdx_font_new (const gchar* path, gint size) {
	SdxFont* self;
	SdxFilesFileHandle* file = NULL;
	const gchar* _tmp0_;
	SdxFilesFileHandle* _tmp1_;
	SDL_RWops* _tmp2_;
	SDL_RWops* _tmp3_;
	gint _tmp4_;
	TTF_Font* _tmp5_;
	const gchar* _tmp6_;
	gchar* _tmp7_;
	gint _tmp8_;
	g_return_val_if_fail (path != NULL, NULL);
	self = g_slice_new0 (SdxFont);
	sdx_font_instance_init (self);
	_tmp0_ = path;
	_tmp1_ = sdx_files_Default (_tmp0_);
	file = _tmp1_;
	_tmp2_ = sdx_files_file_handle_GetRWops (file);
	_SDL_FreeRW0 (self->raw);
	self->raw = _tmp2_;
	_tmp3_ = self->raw;
	_tmp4_ = size;
	_tmp5_ = TTF_OpenFontRW (_tmp3_, 0, _tmp4_);
	_TTF_CloseFont0 (self->innerFont);
	self->innerFont = _tmp5_;
	_tmp6_ = path;
	_tmp7_ = g_strdup (_tmp6_);
	_g_free0 (self->path);
	self->path = _tmp7_;
	_tmp8_ = size;
	self->size = _tmp8_;
	_sdx_files_file_handle_release0 (file);
	return self;
}


/**
 *  Render text for Sprite.fromRenderedText
 *
 * @param text to generate surface from
 * @param fg foreground color of text
 * @param bg background color of sprite
 * @return new Surface
 */
SDL_Surface* sdx_font_Render (SdxFont* self, const gchar* text, SDL_Color fg, SDL_Color* bg) {
	SDL_Surface* result = NULL;
	SDL_Color* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (text != NULL, NULL);
	_tmp0_ = bg;
	if (_tmp0_ == NULL) {
		TTF_Font* _tmp1_;
		const gchar* _tmp2_;
		SDL_Color _tmp3_;
		SDL_Surface* _tmp4_;
		_tmp1_ = self->innerFont;
		_tmp2_ = text;
		_tmp3_ = fg;
		_tmp4_ = TTF_RenderUTF8_Solid (_tmp1_, _tmp2_, _tmp3_);
		result = _tmp4_;
		return result;
	} else {
		TTF_Font* _tmp5_;
		const gchar* _tmp6_;
		SDL_Color _tmp7_;
		SDL_Color* _tmp8_;
		SDL_Surface* _tmp9_;
		_tmp5_ = self->innerFont;
		_tmp6_ = text;
		_tmp7_ = fg;
		_tmp8_ = bg;
		_tmp9_ = TTF_RenderUTF8_Shaded (_tmp5_, _tmp6_, _tmp7_, *_tmp8_);
		result = _tmp9_;
		return result;
	}
}


static void sdx_font_instance_init (SdxFont * self) {
	gint _tmp0_;
	gint _tmp1_;
	self->ref_count = 1;
	_tmp0_ = sdx_font_uniqueId;
	sdx_font_uniqueId = _tmp0_ + 1;
	_tmp1_ = sdx_font_uniqueId;
	self->id = _tmp1_;
}


void sdx_font_free (SdxFont * self) {
	_g_free0 (self->path);
	_TTF_CloseFont0 (self->innerFont);
	_SDL_FreeRW0 (self->raw);
	g_slice_free (SdxFont, self);
}





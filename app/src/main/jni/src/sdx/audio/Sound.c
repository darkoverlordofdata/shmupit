/** updated by adriac */
/* Sound.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Sound.vala, do not modify */

/*[Adriac:Sdx.Audio::Sound:SdxAudioSound:sdx_audio_sound]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <SDL_mixer.h>
#include <SDL_rwops.h>

typedef struct _SdxAudioSound SdxAudioSound;
#define _Mix_FreeChunk0(var) ((var == NULL) ? NULL : (var = (Mix_FreeChunk (var), NULL)))
typedef struct _SdxFilesFileHandle SdxFilesFileHandle;
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))

struct _SdxAudioSound {
	gint ref_count;
	Mix_Chunk* chunk;
};



void sdx_audio_sound_free (SdxAudioSound * self);
static void sdx_audio_sound_instance_init (SdxAudioSound * self);
SdxAudioSound* sdx_audio_sound_retain (SdxAudioSound* self);
void sdx_audio_sound_release (SdxAudioSound* self);
void sdx_audio_sound_free (SdxAudioSound* self);
void sdx_files_file_handle_free (SdxFilesFileHandle * self);
SdxAudioSound* sdx_audio_sound_new (SdxFilesFileHandle* file);
SDL_RWops* sdx_files_file_handle_GetRWops (SdxFilesFileHandle* self);
void sdx_audio_sound_Play (SdxAudioSound* self, gint loops);


SdxAudioSound* sdx_audio_sound_retain (SdxAudioSound* self) {
	SdxAudioSound* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_audio_sound_release (SdxAudioSound* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_audio_sound_free (self);
	}
}


SdxAudioSound* sdx_audio_sound_new (SdxFilesFileHandle* file) {
	SdxAudioSound* self;
	SdxFilesFileHandle* _tmp0_;
	SDL_RWops* _tmp1_;
	SDL_RWops* _tmp2_;
	Mix_Chunk* _tmp3_;
	g_return_val_if_fail (file != NULL, NULL);
	self = g_slice_new0 (SdxAudioSound);
	sdx_audio_sound_instance_init (self);
	_tmp0_ = file;
	_tmp1_ = sdx_files_file_handle_GetRWops (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = Mix_LoadWAV_RW (_tmp2_, 0);
	_Mix_FreeChunk0 (self->chunk);
	self->chunk = _tmp3_;
	_SDL_FreeRW0 (_tmp2_);
	return self;
}


void sdx_audio_sound_Play (SdxAudioSound* self, gint loops) {
	Mix_Chunk* _tmp0_;
	gint _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->chunk;
	_tmp1_ = loops;
	Mix_PlayChannel (-1, _tmp0_, _tmp1_);
}


static void sdx_audio_sound_instance_init (SdxAudioSound * self) {
	self->ref_count = 1;
}


void sdx_audio_sound_free (SdxAudioSound * self) {
	_Mix_FreeChunk0 (self->chunk);
	g_slice_free (SdxAudioSound, self);
}





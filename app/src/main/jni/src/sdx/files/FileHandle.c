/** updated by adriac */
/* FileHandle.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from FileHandle.vala, do not modify */

/*[Adriac:Sdx.Files::FileHandle:SdxFilesFileHandle:sdx_files_file_handle]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <SDL_rwops.h>

typedef struct _SdxFilesFileHandle SdxFilesFileHandle;
typedef struct _SdxUtilsFile SdxUtilsFile;

#define SDX_TYPE_FILE_TYPE (sdx_file_type_get_type ())
// symtbl.1 sdx_utils_file
void sdx_utils_file_release (SdxUtilsFile* self);
void sdx_utils_file_free (SdxUtilsFile* self);
SdxUtilsFile* sdx_utils_file_retain (SdxUtilsFile* self);
#define _sdx_utils_file_release0(var) ((var == NULL) ? NULL : (var = (sdx_utils_file_release (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _SDL_FreeRW0(var) ((var == NULL) ? NULL : (var = (SDL_FreeRW (var), NULL)))

typedef enum  {
	SDX_FILE_TYPE_Resource = 1,
	SDX_FILE_TYPE_Asset,
	SDX_FILE_TYPE_Absolute,
	SDX_FILE_TYPE_Relative
} SdxFileType;

struct _SdxFilesFileHandle {
	gint ref_count;
	SdxUtilsFile* file;
	gchar* path;
	SdxFileType type;
};

typedef enum  {
	SDX_SDL_EXCEPTION_Initialization,
	SDX_SDL_EXCEPTION_ImageInitialization,
	SDX_SDL_EXCEPTION_TtfInitialization,
	SDX_SDL_EXCEPTION_TextureFilteringNotEnabled,
	SDX_SDL_EXCEPTION_OpenWindow,
	SDX_SDL_EXCEPTION_CreateRenderer,
	SDX_SDL_EXCEPTION_InvalidForPlatform,
	SDX_SDL_EXCEPTION_UnableToLoadResource,
	SDX_SDL_EXCEPTION_UnableToLoadSurface,
	SDX_SDL_EXCEPTION_UnableToLoadTexture,
	SDX_SDL_EXCEPTION_NullPointer,
	SDX_SDL_EXCEPTION_NoSuchElement,
	SDX_SDL_EXCEPTION_IllegalStateException,
	SDX_SDL_EXCEPTION_IllegalArgumentException,
	SDX_SDL_EXCEPTION_RuntimeException,
	SDX_SDL_EXCEPTION_NotReached
} SdxSdlException;
#define SDX_SDL_EXCEPTION sdx_sdl_exception_quark ()


void sdx_files_file_handle_free (SdxFilesFileHandle * self);
void sdx_utils_file_free (SdxUtilsFile * self);
GType sdx_file_type_get_type (void) G_GNUC_CONST;
static void sdx_files_file_handle_instance_init (SdxFilesFileHandle * self);
SdxFilesFileHandle* sdx_files_file_handle_retain (SdxFilesFileHandle* self);
void sdx_files_file_handle_release (SdxFilesFileHandle* self);
void sdx_files_file_handle_free (SdxFilesFileHandle* self);
SdxFilesFileHandle* sdx_files_file_handle_new (const gchar* path, SdxFileType type);
SdxUtilsFile* sdx_utils_file_new (const gchar* path);
SDL_RWops* sdx_files_file_handle_GetRWops (SdxFilesFileHandle* self);
gchar* sdx_files_file_handle_GetPath (SdxFilesFileHandle* self);
GQuark sdx_sdl_exception_quark (void);
gchar* sdx_files_file_handle_Read (SdxFilesFileHandle* self);
gchar* sdx_utils_file_Read (SdxUtilsFile* self);
SdxFileType sdx_files_file_handle_GetType (SdxFilesFileHandle* self);
gchar* sdx_files_file_handle_GetName (SdxFilesFileHandle* self);
gchar* sdx_utils_file_GetName (SdxUtilsFile* self);
gchar* sdx_files_file_handle_GetExt (SdxFilesFileHandle* self);
gchar* sdx_utils_file_GetPath (SdxUtilsFile* self);
SdxFilesFileHandle* sdx_files_file_handle_GetParent (SdxFilesFileHandle* self);
gchar* sdx_utils_file_GetParent (SdxUtilsFile* self);
gboolean sdx_files_file_handle_Exists (SdxFilesFileHandle* self);
gboolean sdx_utils_file_Exists (SdxUtilsFile* self);
SdxFilesFileHandle* sdx_files_file_handle_Child (SdxFilesFileHandle* self, const gchar* name);
#define SDX_UTILS_PathSeparator "/"


SdxFilesFileHandle* sdx_files_file_handle_retain (SdxFilesFileHandle* self) {
	SdxFilesFileHandle* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void sdx_files_file_handle_release (SdxFilesFileHandle* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		sdx_files_file_handle_free (self);
	}
}


SdxFilesFileHandle* sdx_files_file_handle_new (const gchar* path, SdxFileType type) {
	SdxFilesFileHandle* self;
	SdxFileType _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	const gchar* _tmp3_;
	SdxUtilsFile* _tmp4_;
	g_return_val_if_fail (path != NULL, NULL);
	self = g_slice_new0 (SdxFilesFileHandle);
	sdx_files_file_handle_instance_init (self);
	_tmp0_ = type;
	self->type = _tmp0_;
	_tmp1_ = path;
	_tmp2_ = g_strdup (_tmp1_);
	_g_free0 (self->path);
	self->path = _tmp2_;
	_tmp3_ = path;
	_tmp4_ = sdx_utils_file_new (_tmp3_);
	_sdx_utils_file_release0 (self->file);
	self->file = _tmp4_;
	return self;
}


/**
 * Loads a raw resource value
 */
SDL_RWops* sdx_files_file_handle_GetRWops (SdxFilesFileHandle* self) {
	SDL_RWops* result = NULL;
	SdxFileType _tmp0_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->type;
	if (_tmp0_ == SDX_FILE_TYPE_Resource) {
		result = NULL;
		return result;
	} else {
		SDL_RWops* raw = NULL;
		gchar* _tmp1_;
		gchar* _tmp2_;
		SDL_RWops* _tmp3_;
		SDL_RWops* _tmp4_;
		SDL_RWops* _tmp5_;
		_tmp1_ = sdx_files_file_handle_GetPath (self);
		_tmp2_ = _tmp1_;
		_tmp3_ = SDL_RWFromFile (_tmp2_, "r");
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		raw = _tmp4_;
		_tmp5_ = raw;
		if (_tmp5_ == NULL) {
			gchar* _tmp6_;
			gchar* _tmp7_;
			GError* _tmp8_;
			GError* _tmp9_;
			_tmp6_ = sdx_files_file_handle_GetPath (self);
			_tmp7_ = _tmp6_;
			_tmp8_ = g_error_new_literal (SDX_SDL_EXCEPTION, SDX_SDL_EXCEPTION_UnableToLoadResource, _tmp7_);
			_tmp9_ = _tmp8_;
			_g_free0 (_tmp7_);
			_inner_error_ = _tmp9_;
			_SDL_FreeRW0 (raw);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = raw;
		return result;
	}
}


gchar* sdx_files_file_handle_Read (SdxFilesFileHandle* self) {
	gchar* result = NULL;
	SdxFileType _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->type;
	if (_tmp0_ == SDX_FILE_TYPE_Resource) {
		gchar* _tmp1_;
		_tmp1_ = g_strdup ("");
		result = _tmp1_;
		return result;
	} else {
		SdxUtilsFile* _tmp2_;
		gchar* _tmp3_;
		_tmp2_ = self->file;
		_tmp3_ = sdx_utils_file_Read (_tmp2_);
		result = _tmp3_;
		return result;
	}
}


SdxFileType sdx_files_file_handle_GetType (SdxFilesFileHandle* self) {
	SdxFileType result = 0;
	SdxFileType _tmp0_;
	g_return_val_if_fail (self != NULL, 0);
	_tmp0_ = self->type;
	result = _tmp0_;
	return result;
}


gchar* sdx_files_file_handle_GetName (SdxFilesFileHandle* self) {
	gchar* result = NULL;
	SdxUtilsFile* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->file;
	_tmp1_ = sdx_utils_file_GetName (_tmp0_);
	result = _tmp1_;
	return result;
}


static gint string_LastIndexOf (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = g_strrstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


static glong string_strnlen (gchar* str, glong maxlen) {
	glong result = 0L;
	gchar* end = NULL;
	gchar* _tmp0_;
	glong _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	_tmp0_ = str;
	_tmp1_ = maxlen;
	_tmp2_ = memchr (_tmp0_, 0, (gsize) _tmp1_);
	end = _tmp2_;
	_tmp3_ = end;
	if (_tmp3_ == NULL) {
		glong _tmp4_;
		_tmp4_ = maxlen;
		result = _tmp4_;
		return result;
	} else {
		gchar* _tmp5_;
		gchar* _tmp6_;
		_tmp5_ = end;
		_tmp6_ = str;
		result = (glong) (_tmp5_ - _tmp6_);
		return result;
	}
}


static gchar* string_SubString (const gchar* self, glong offset, glong len) {
	gchar* result = NULL;
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	glong _tmp1_;
	glong _tmp8_;
	glong _tmp14_;
	glong _tmp17_;
	glong _tmp18_;
	glong _tmp19_;
	glong _tmp20_;
	glong _tmp21_;
	gchar* _tmp22_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp1_ = offset;
	if (_tmp1_ >= ((glong) 0)) {
		glong _tmp2_;
		_tmp2_ = len;
		_tmp0_ = _tmp2_ >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		glong _tmp3_;
		glong _tmp4_;
		glong _tmp5_;
		_tmp3_ = offset;
		_tmp4_ = len;
		_tmp5_ = string_strnlen ((gchar*) self, _tmp3_ + _tmp4_);
		string_length = _tmp5_;
	} else {
		gint _tmp6_;
		gint _tmp7_;
		_tmp6_ = strlen (self);
		_tmp7_ = _tmp6_;
		string_length = (glong) _tmp7_;
	}
	_tmp8_ = offset;
	if (_tmp8_ < ((glong) 0)) {
		glong _tmp9_;
		glong _tmp10_;
		glong _tmp11_;
		_tmp9_ = string_length;
		_tmp10_ = offset;
		offset = _tmp9_ + _tmp10_;
		_tmp11_ = offset;
		g_return_val_if_fail (_tmp11_ >= ((glong) 0), NULL);
	} else {
		glong _tmp12_;
		glong _tmp13_;
		_tmp12_ = offset;
		_tmp13_ = string_length;
		g_return_val_if_fail (_tmp12_ <= _tmp13_, NULL);
	}
	_tmp14_ = len;
	if (_tmp14_ < ((glong) 0)) {
		glong _tmp15_;
		glong _tmp16_;
		_tmp15_ = string_length;
		_tmp16_ = offset;
		len = _tmp15_ - _tmp16_;
	}
	_tmp17_ = offset;
	_tmp18_ = len;
	_tmp19_ = string_length;
	g_return_val_if_fail ((_tmp17_ + _tmp18_) <= _tmp19_, NULL);
	_tmp20_ = offset;
	_tmp21_ = len;
	_tmp22_ = g_strndup (((gchar*) self) + _tmp20_, (gsize) _tmp21_);
	result = _tmp22_;
	return result;
}


static gint string_IndexOf (const gchar* self, const gchar* needle, gint start_index) {
	gint result = 0;
	gchar* _result_ = NULL;
	gint _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	g_return_val_if_fail (self != NULL, 0);
	g_return_val_if_fail (needle != NULL, 0);
	_tmp0_ = start_index;
	_tmp1_ = needle;
	_tmp2_ = strstr (((gchar*) self) + _tmp0_, (gchar*) _tmp1_);
	_result_ = _tmp2_;
	_tmp3_ = _result_;
	if (_tmp3_ != NULL) {
		gchar* _tmp4_;
		_tmp4_ = _result_;
		result = (gint) (_tmp4_ - ((gchar*) self));
		return result;
	} else {
		result = -1;
		return result;
	}
}


gchar* sdx_files_file_handle_GetExt (SdxFilesFileHandle* self) {
	gchar* result = NULL;
	gchar* name = NULL;
	gchar* _tmp0_;
	gint i = 0;
	const gchar* _tmp1_;
	gint _tmp2_;
	gint _tmp3_;
	gchar* ext = NULL;
	const gchar* _tmp5_;
	gint _tmp6_;
	gchar* _tmp7_;
	const gchar* _tmp8_;
	gint _tmp9_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = sdx_files_file_handle_GetName (self);
	name = _tmp0_;
	_tmp1_ = name;
	_tmp2_ = string_LastIndexOf (_tmp1_, ".", 0);
	i = _tmp2_;
	_tmp3_ = i;
	if (_tmp3_ < 0) {
		gchar* _tmp4_;
		_tmp4_ = g_strdup ("");
		result = _tmp4_;
		_g_free0 (name);
		return result;
	}
	_tmp5_ = name;
	_tmp6_ = i;
	_tmp7_ = string_SubString (_tmp5_, (glong) _tmp6_, (glong) -1);
	ext = _tmp7_;
	_tmp8_ = ext;
	_tmp9_ = string_IndexOf (_tmp8_, ".", 0);
	if (_tmp9_ < 0) {
		const gchar* _tmp10_;
		gchar* _tmp11_;
		_tmp10_ = ext;
		_tmp11_ = g_strconcat (".", _tmp10_, NULL);
		_g_free0 (ext);
		ext = _tmp11_;
	}
	result = ext;
	_g_free0 (name);
	return result;
}


gchar* sdx_files_file_handle_GetPath (SdxFilesFileHandle* self) {
	gchar* result = NULL;
	SdxUtilsFile* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->file;
	_tmp1_ = sdx_utils_file_GetPath (_tmp0_);
	result = _tmp1_;
	return result;
}


SdxFilesFileHandle* sdx_files_file_handle_GetParent (SdxFilesFileHandle* self) {
	SdxFilesFileHandle* result = NULL;
	SdxUtilsFile* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	SdxFileType _tmp3_;
	SdxFilesFileHandle* _tmp4_;
	SdxFilesFileHandle* _tmp5_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->file;
	_tmp1_ = sdx_utils_file_GetParent (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = self->type;
	_tmp4_ = sdx_files_file_handle_new (_tmp2_, _tmp3_);
	_tmp5_ = _tmp4_;
	_g_free0 (_tmp2_);
	result = _tmp5_;
	return result;
}


gboolean sdx_files_file_handle_Exists (SdxFilesFileHandle* self) {
	gboolean result = FALSE;
	SdxFileType _tmp0_;
	g_return_val_if_fail (self != NULL, FALSE);
	_tmp0_ = self->type;
	if (_tmp0_ == SDX_FILE_TYPE_Resource) {
		result = TRUE;
		return result;
	} else {
		SdxUtilsFile* _tmp1_;
		gboolean _tmp2_;
		_tmp1_ = self->file;
		_tmp2_ = sdx_utils_file_Exists (_tmp1_);
		result = _tmp2_;
		return result;
	}
}


/**
 * Gets a file that is a sibling
 */
SdxFilesFileHandle* sdx_files_file_handle_Child (SdxFilesFileHandle* self, const gchar* name) {
	SdxFilesFileHandle* result = NULL;
	SdxUtilsFile* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	const gchar* _tmp5_;
	gchar* _tmp6_;
	gchar* _tmp7_;
	SdxFileType _tmp8_;
	SdxFilesFileHandle* _tmp9_;
	SdxFilesFileHandle* _tmp10_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = self->file;
	_tmp1_ = sdx_utils_file_GetPath (_tmp0_);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strconcat (_tmp2_, SDX_UTILS_PathSeparator, NULL);
	_tmp4_ = _tmp3_;
	_tmp5_ = name;
	_tmp6_ = g_strconcat (_tmp4_, _tmp5_, NULL);
	_tmp7_ = _tmp6_;
	_tmp8_ = self->type;
	_tmp9_ = sdx_files_file_handle_new (_tmp7_, _tmp8_);
	_tmp10_ = _tmp9_;
	_g_free0 (_tmp7_);
	_g_free0 (_tmp4_);
	_g_free0 (_tmp2_);
	result = _tmp10_;
	return result;
}


static void sdx_files_file_handle_instance_init (SdxFilesFileHandle * self) {
	self->ref_count = 1;
}


void sdx_files_file_handle_free (SdxFilesFileHandle * self) {
	_sdx_utils_file_release0 (self->file);
	_g_free0 (self->path);
	g_slice_free (SdxFilesFileHandle, self);
}





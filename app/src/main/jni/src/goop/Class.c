/** updated by adriac */
/* Class.c generated by valac 0.36.4-dirty, the Vala compiler
 * generated from Class.vala, do not modify */

/*[Adriac:::]:]:]]*/
/*[Adriac::Object:that:Objectthat:that]*/
/*[Adriac:::Class:Class:class]*/
/*[Adriac:::Klass:Klass:klass]*/
/*[Adriac:::Object:Object:object]*/
/*[Adriac:::to:to:to]*/
/* ******************************************************************************
 * Copyright 2017 darkoverlordofdata.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 ******************************************************************************/
/*  #if (!NOGOBJECT && !EMSCRIPTEN)*/
/*  /***/
/*   * Base class to replace GLib.Object*/
/*   * /*/
/*  public class Object {}*/
/*  #endif*/

#include <glib.h>
#include <glib-object.h>
#include <stdlib.h>
#include <string.h>

typedef struct _Klass Klass;
typedef struct _Class Class;

#define TYPE_GUID (guid_get_type ())
typedef struct _Guid Guid;
#define _guid_free0(var) ((var == NULL) ? NULL : (var = (guid_free (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_hash_table_unref0(var) ((var == NULL) ? NULL : (var = (g_hash_table_unref (var), NULL)))
// symtbl.1 class
void class_release (Class* self);
void class_free (Class* self);
Class* class_retain (Class* self);
#define _class_release0(var) ((var == NULL) ? NULL : (var = (class_release (var), NULL)))

/**
 * Class Registration Exceptions
 */
typedef enum  {
	EXCEPTION_ClassNotRegistered,
	EXCEPTION_ClassAlreadyRegistered
} Exception;
#define EXCEPTION exception_quark ()
struct _Klass {
	gint ref_count;
	Class* klass;
};

struct _Guid {
	guint32 data1;
	guint16 data2;
	guint16 data3;
	guint8 data4[8];
};

struct _Class {
	gint ref_count;
	Guid* ClsId;
	Guid* clsId;
	gchar* uuid;
	gchar* name;
};


extern GHashTable* class_registry;
GHashTable* class_registry = NULL;
extern GHashTable* class_classes;
GHashTable* class_classes = NULL;

GQuark exception_quark (void);
void klass_free (Klass * self);
void class_free (Class * self);
static void klass_instance_init (Klass * self);
Klass* klass_retain (Klass* self);
void klass_release (Klass* self);
void klass_free (Klass* self);
Klass* klass_new (void);
GType guid_get_type (void) G_GNUC_CONST;
Guid* guid_dup (const Guid* self);
void guid_free (Guid* self);
static void class_instance_init (Class * self);
Class* class_retain (Class* self);
void class_release (Class* self);
void class_free (Class* self);
Class* class_Register (const gchar* name, const gchar* guid);
static void _g_free0_ (gpointer var);
// symtbl.2 class
void class_release (Class* self);
void class_free (Class* self);
Class* class_retain (Class* self);
static void _class_release0_ (gpointer var);
gchar* guid_Generate (void);
Class* class_new (const gchar* name, const gchar* uuid);
Class* class_Get (const gchar* name);
Guid guid_Parse (const gchar* v4);
gchar* class_ToString (Class* self);


GQuark exception_quark (void) {
	return g_quark_from_static_string ("exception-quark");
}


Klass* klass_retain (Klass* self) {
	Klass* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void klass_release (Klass* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		klass_free (self);
	}
}


Klass* klass_new (void) {
	Klass* self;
	self = g_slice_new0 (Klass);
	klass_instance_init (self);
	return self;
}


static void klass_instance_init (Klass * self) {
	self->ref_count = 1;
}


void klass_free (Klass * self) {
	g_slice_free (Klass, self);
}


Class* class_retain (Class* self) {
	Class* result = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_atomic_int_add ((volatile gint *) (&self->ref_count), 1);
	result = self;
	return result;
}


void class_release (Class* self) {
	gboolean _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_atomic_int_dec_and_test ((volatile gint *) (&self->ref_count));
	if (_tmp0_) {
		class_free (self);
	}
}


/**
 * Registers a classid and returns the unique rehash
 */
static void _g_free0_ (gpointer var) {
	var = (g_free (var), NULL);
}


// symtbl.2 class
void class_release (Class* self);
void class_free (Class* self);
Class* class_retain (Class* self);
static void _class_release0_ (gpointer var) {
	(var == NULL) ? NULL : (var = (class_release (var), NULL));
}


static gpointer _class_retain0 (gpointer self) {
	return self ? class_retain (self) : NULL;
}


Class* class_Register (const gchar* name, const gchar* guid) {
	Class* result = NULL;
	GHashTable* _tmp0_;
	GHashTable* _tmp4_;
	Class* klass = NULL;
	GHashTable* _tmp6_;
	const gchar* _tmp7_;
	gconstpointer _tmp8_;
	Class* _tmp9_;
	Class* _tmp10_;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = class_classes;
	if (_tmp0_ == NULL) {
		GHashFunc _tmp1_;
		GEqualFunc _tmp2_;
		GHashTable* _tmp3_;
		_tmp1_ = g_str_hash;
		_tmp2_ = g_str_equal;
		_tmp3_ = g_hash_table_new_full (_tmp1_, _tmp2_, _g_free0_, _class_release0_);
		_g_hash_table_unref0 (class_classes);
		class_classes = _tmp3_;
	}
	_tmp4_ = class_registry;
	if (_tmp4_ == NULL) {
		GHashTable* _tmp5_;
		_tmp5_ = g_hash_table_new_full (NULL, NULL, NULL, _class_release0_);
		_g_hash_table_unref0 (class_registry);
		class_registry = _tmp5_;
	}
	_tmp6_ = class_classes;
	_tmp7_ = name;
	_tmp8_ = g_hash_table_lookup (_tmp6_, _tmp7_);
	_tmp9_ = _class_retain0 ((Class*) _tmp8_);
	klass = _tmp9_;
	_tmp10_ = klass;
	if (_tmp10_ == NULL) {
		gchar* _tmp11_ = NULL;
		const gchar* _tmp12_;
		gchar* uuid = NULL;
		gchar* _tmp16_;
		const gchar* _tmp17_;
		const gchar* _tmp18_;
		Class* _tmp19_;
		GHashTable* _tmp20_;
		const gchar* _tmp21_;
		gchar* _tmp22_;
		Class* _tmp23_;
		Class* _tmp24_;
		GHashTable* _tmp25_;
		Class* _tmp26_;
		Guid* _tmp27_;
		Class* _tmp28_;
		Class* _tmp29_;
		_tmp12_ = guid;
		if (_tmp12_ == NULL) {
			gchar* _tmp13_;
			_tmp13_ = guid_Generate ();
			_g_free0 (_tmp11_);
			_tmp11_ = _tmp13_;
		} else {
			const gchar* _tmp14_;
			gchar* _tmp15_;
			_tmp14_ = guid;
			_tmp15_ = g_strdup (_tmp14_);
			_g_free0 (_tmp11_);
			_tmp11_ = _tmp15_;
		}
		_tmp16_ = g_strdup (_tmp11_);
		uuid = _tmp16_;
		_tmp17_ = name;
		_tmp18_ = uuid;
		_tmp19_ = class_new (_tmp17_, _tmp18_);
		_class_release0 (klass);
		klass = _tmp19_;
		_tmp20_ = class_classes;
		_tmp21_ = name;
		_tmp22_ = g_strdup (_tmp21_);
		_tmp23_ = klass;
		_tmp24_ = _class_retain0 (_tmp23_);
		g_hash_table_insert (_tmp20_, _tmp22_, _tmp24_);
		_tmp25_ = class_registry;
		_tmp26_ = klass;
		_tmp27_ = _tmp26_->clsId;
		_tmp28_ = klass;
		_tmp29_ = _class_retain0 (_tmp28_);
		g_hash_table_insert (_tmp25_, _tmp27_, _tmp29_);
		_g_free0 (uuid);
		_g_free0 (_tmp11_);
	}
	result = klass;
	return result;
}


/**
 */
Class* class_Get (const gchar* name) {
	Class* result = NULL;
	GHashTable* _tmp0_;
	Class* klass = NULL;
	GHashTable* _tmp3_;
	const gchar* _tmp4_;
	gconstpointer _tmp5_;
	Class* _tmp6_;
	Class* _tmp7_;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (name != NULL, NULL);
	_tmp0_ = class_classes;
	if (_tmp0_ == NULL) {
		const gchar* _tmp1_;
		GError* _tmp2_;
		_tmp1_ = name;
		_tmp2_ = g_error_new_literal (EXCEPTION, EXCEPTION_ClassNotRegistered, _tmp1_);
		_inner_error_ = _tmp2_;
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	_tmp3_ = class_classes;
	_tmp4_ = name;
	_tmp5_ = g_hash_table_lookup (_tmp3_, _tmp4_);
	_tmp6_ = _class_retain0 ((Class*) _tmp5_);
	klass = _tmp6_;
	_tmp7_ = klass;
	if (_tmp7_ == NULL) {
		const gchar* _tmp8_;
		GError* _tmp9_;
		_tmp8_ = name;
		_tmp9_ = g_error_new_literal (EXCEPTION, EXCEPTION_ClassNotRegistered, _tmp8_);
		_inner_error_ = _tmp9_;
		_class_release0 (klass);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	result = klass;
	return result;
}


/**
 * Parse a binary guid from string
 * Creates a unique re-hash that fits in one word.
 */
static gpointer _guid_dup0 (gpointer self) {
	return self ? guid_dup (self) : NULL;
}


Class* class_new (const gchar* name, const gchar* uuid) {
	Class* self;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	const gchar* _tmp4_;
	Guid _tmp5_;
	Guid* _tmp6_;
	g_return_val_if_fail (name != NULL, NULL);
	g_return_val_if_fail (uuid != NULL, NULL);
	self = g_slice_new0 (Class);
	class_instance_init (self);
	_tmp0_ = uuid;
	_tmp1_ = g_strdup (_tmp0_);
	_g_free0 (self->uuid);
	self->uuid = _tmp1_;
	_tmp2_ = name;
	_tmp3_ = g_strdup (_tmp2_);
	_g_free0 (self->name);
	self->name = _tmp3_;
	_tmp4_ = uuid;
	_tmp5_ = guid_Parse (_tmp4_);
	_tmp6_ = _guid_dup0 (&_tmp5_);
	_guid_free0 (self->ClsId);
	self->ClsId = _tmp6_;
	self->clsId = &self->ClsId;
	return self;
}


/**
 * String representation of the klass
 */
gchar* class_ToString (Class* self) {
	gchar* result = NULL;
	const gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->uuid;
	_tmp1_ = g_strdup (_tmp0_);
	result = _tmp1_;
	return result;
}


static void class_instance_init (Class * self) {
	self->ref_count = 1;
}


void class_free (Class * self) {
	_guid_free0 (self->ClsId);
	_g_free0 (self->uuid);
	_g_free0 (self->name);
	g_slice_free (Class, self);
}




